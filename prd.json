{
  "version": "1.0",
  "projectName": "atproto-agent-network-pi-loop",
  "description": "Epic #50: Real Pi Agent Loop â€” DO IS the Agent. Replace AI SDK with Pi, implement persistent agent config, session trees, alarm-driven autonomous loop, Pi tools, agent creation API, dashboard enhancements, and self-extending agents.",
  "stories": [
    {
      "id": "story-mlde1mhv",
      "title": "Install Pi deps + replace AI SDK wrapper",
      "description": "**REPLACE AI SDK WITH PI â€” STEP BY STEP**\n\n1. Install Pi packages:\n   ```bash\n   pnpm add @mariozechner/pi-ai@0.52.8 --filter @atproto-agent/network\n   pnpm add @mariozechner/pi-ai@0.52.8 @mariozechner/pi-agent-core@0.52.8 --filter @atproto-agent/agent\n   ```\n\n2. Remove AI SDK packages:\n   ```bash\n   pnpm remove ai @openrouter/ai-sdk-provider --filter @atproto-agent/network\n   ```\n\n3. Read the current ai-provider.ts:\n   ```bash\n   cat apps/network/src/ai-provider.ts\n   ```\n\n4. Write new ai-provider.ts using Pi API:\n   ```typescript\n   import { getModel, complete, type Context } from '@mariozechner/pi-ai'\n   \n   export function getOpenRouterModel(modelId: string) {\n     return getModel('openrouter', modelId)\n   }\n   \n   export async function completeWithOpenRouter(\n     model: string,\n     context: Context,\n     options?: { tools?: any[] }\n   ) {\n     const model_obj = getOpenRouterModel(model)\n     return complete(model_obj, context, options)\n   }\n   ```\n\n5. Read the current agent-factory.ts:\n   ```bash\n   cat apps/network/src/agent-factory.ts\n   ```\n\n6. Rewrite agent-factory.ts to use Pi:\n   - Replace all imports from 'ai' with imports from '@mariozechner/pi-ai'\n   - Replace generateText() calls with complete() calls\n   - Keep the factory function signature the same\n   - Maintain OpenRouter + CF AI Gateway routing\n\n7. Run tests to verify:\n   ```bash\n   pnpm test 2>&1 | tail -5\n   ```\n\n8. Run typecheck:\n   ```bash\n   pnpm typecheck\n   ```\n\nSuccess criteria:\n- All 86 tests pass\n- No imports from 'ai' package remain\n- Agent factory returns working prompt() function\n- Typecheck clean",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "pnpm install succeeds with Pi packages",
        "No imports from 'ai' or '@openrouter/ai-sdk-provider' remain",
        "Agent /prompt endpoint uses Pi complete()",
        "All 86+ tests pass",
        "TypeScript compiles clean"
      ]
    },
    {
      "id": "story-mlde1tos",
      "title": "Agent config schema + DO storage",
      "description": "GitHub Issue #52. Define and persist per-agent configuration in DO storage. Create AgentConfig interface: name, personality (system prompt), specialty, model (default moonshotai/kimi-k2.5), fastModel (google/gemini-2.0-flash-001), loopIntervalMs (default 60000), goals array (AgentGoal with id/description/priority/status/progress/createdAt/completedAt), enabledTools array. Store config in DO storage under 'config' key in AgentDO (apps/network/src/agent.ts). Add GET /agents/{name}/config endpoint (returns config). Add PATCH /agents/{name}/config endpoint (partial update, merges with existing). Config is set at agent creation time and updatable at runtime. Add types to packages/core/src/types.ts or a new file. Add tests for config CRUD operations.",
      "priority": 2,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "AgentConfig interface defined with all fields",
        "Config persists in DO storage across requests",
        "GET /agents/{name}/config returns stored config",
        "PATCH /agents/{name}/config merges updates",
        "Tests for config storage and retrieval"
      ]
    },
    {
      "id": "story-mlde2057",
      "title": "Pi session persistence in DO storage",
      "description": "GitHub Issue #53. Persist Pi session context (messages array) in DO storage so agents maintain conversation history across alarms and DO evictions. In AgentDO (apps/network/src/agent.ts): save Pi Context messages to DO storage after each interaction under 'session' key. Load session on DO initialize(). Implement window management: keep last 50 messages in DO storage, archive overflow to D1 (agent-records). Add helper methods: loadSession(), saveSession(), trimSession(). The session should include role, content, timestamp, and any tool call results. Support Pi session branching concept (store branch points). Add tests for session save/load/trim/branch.",
      "priority": 3,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "Session messages persist in DO storage",
        "Session loads correctly on DO init",
        "Window management trims to 50 messages",
        "Overflow archived to D1",
        "Tests for save/load/trim"
      ]
    },
    {
      "id": "story-4a-alarm-chain",
      "title": "4a: Bare alarm chain + start/stop API",
      "description": "GitHub Issue #60. The alarm skeleton â€” no Pi, no inbox. Just the chain that keeps ticking. Implement alarm() handler in AgentDO that logs, increments counter, and schedules next alarm via ctx.storage.setAlarm(). Add startLoop()/stopLoop() methods. HTTP routes: POST /agents/:name/loop/start, POST /agents/:name/loop/stop, GET /agents/:name/loop/status. Safety: check loopRunning flag, reject loopIntervalMs < 5000, errors must not break chain. Files: apps/network/src/agent.ts, apps/network/src/index.ts, apps/network/src/agent-do.test.ts. Skill ref: .agents/skills/cloudflare-do (alarm patterns).\n\nAfter passing tests: deploy, smoke test, report. See AGENTS.md SHIP AND VERIFY mandate.",
      "priority": 4,
      "passes": true,
      "acceptanceCriteria": [
        "alarm() fires and reschedules",
        "startLoop()/stopLoop() work via API",
        "Error in alarm does not break chain",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-4b-observe",
      "title": "4b: Observe phase â€” inbox + event collection",
      "description": "GitHub Issue #61. Depends on #60. Implement observe() method that queries memory.list({collection: \"agent.comms.message\"}) for unread inbox messages, decrypts them, marks as processed, and collects events since last alarm. Returns structured Observations object. Wire into alarm() handler. Files: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts. Skill ref: .agents/skills/envelope-encryption, .agents/skills/d1-patterns.\n\nAfter passing tests: deploy, smoke test, report. See AGENTS.md SHIP AND VERIFY mandate.",
      "priority": 5,
      "passes": true,
      "acceptanceCriteria": [
        "observe() returns structured Observations",
        "Inbox messages decrypted and collected",
        "Empty inbox handled gracefully",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-4c-think-act-reflect",
      "title": "4c: Think/Act/Reflect â€” Pi loop cycle",
      "description": "GitHub Issue #62. Depends on #60, #61. The brain: think() builds prompt from observations+goals+memories, calls Pi complete() with session context. act() executes tool calls (max 5 steps, 30s timeout). reflect() saves session, updates goals. Wire observe->think->act->reflect into alarm(). Files: apps/network/src/agent.ts, packages/agent/src/agent.ts, apps/network/src/agent-do.test.ts. Skill ref: .agents/skills/pi-agent (complete(), tools, session).\n\nTESTING APPROACH: Integration tests against real deployed worker.\n1. Unit tests for pure function logic only (if any)\n2. Integration test in apps/network/src/network.e2e.test.ts:\n   - POST /agents/test-think/loop/start with admin auth\n   - Wait for alarm to fire (~5s with min interval)\n   - GET /agents/test-think/loop/status â€” verify loopCount incremented\n   - Verify agent prompted Pi (check session state or response)\n   - Stop loop, verify it stops\n3. Deploy first, then run e2e against https://agent-network.joelhooks.workers.dev\n4. Use ADMIN_TOKEN from env for auth\n\nExisting unit tests in agent-do.test.ts can stay as sanity checks, but the REAL validation is the integration test passing against prod.\n\nAfter passing tests: deploy, smoke test, report. See AGENTS.md SHIP AND VERIFY mandate.",
      "priority": 6,
      "passes": true,
      "acceptanceCriteria": [
        "Pi called with correct context",
        "Tool calls executed with safety limits",
        "Session persisted after reflect",
        "Goals updated when Pi decides",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-4d-ws-broadcast",
      "title": "4d: WebSocket broadcast of loop events",
      "description": "GitHub Issue #63. Depends on #62. Broadcast loop lifecycle events (loop.started, loop.observe, loop.think, loop.act, loop.reflect, loop.sleep, loop.error) to connected WS clients via ctx.getWebSockets(). Events match docs/O11Y.md schema (trace_id, span_id, agent_did). Handle stale connections gracefully. Files: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts.\n\nTESTING APPROACH: Real integration tests against deployed worker, NOT unit test mocks.\n1. Deploy to https://agent-network.joelhooks.workers.dev\n2. Write integration test (apps/network/src/network.e2e.test.ts or similar) that:\n   - Opens a real WebSocket to wss://agent-network.joelhooks.workers.dev/agents/test-ws/ws\n   - POSTs to /agents/test-ws/loop/start with admin auth\n   - Asserts lifecycle events arrive on the socket (loop.observe, loop.think, loop.reflect)\n   - Verifies O11Y schema (trace_id, span_id, agent_did)\n   - Tests stale connection handling (connect, disconnect, verify loop continues)\n3. Use ADMIN_TOKEN from env for auth\n4. Validation: deploy + e2e test pass against real CF\n\nDO NOT mock WebSocketPair. DO NOT use miniflare. Test against the real deployed worker.",
      "priority": 7,
      "passes": true,
      "acceptanceCriteria": [
        "Loop events broadcast to connected clients",
        "Events match O11Y schema",
        "Dead connections handled gracefully",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-mlde2jqb",
      "title": "Pi tool definitions",
      "description": "GitHub Issue #55. Define Pi-native tools for agents. Rewrite buildTools() in AgentDO to return Pi AgentTool format with split output (text for LLM) and details (structured for dashboard). Tools: 1) remember â€” store encrypted memory record, returns {output: \"Stored memory {id}\", details: {id}}. 2) recall â€” search memories semantically using Vectorize binding if available, fallback to list+filter, returns matching memories. 3) message â€” send agent.comms.message to another agent DO via RELAY namespace, includes sender DID and content. 4) search â€” semantic search across all agent memories on the network (query Vectorize index). 5) set_goal â€” add/update/complete goals on the agent config stored in DO. 6) think_aloud â€” record reasoning that gets broadcast via WebSocket to dashboard but NOT included in LLM context (UI-only). Each tool should have proper TypeBox or JSON Schema parameter definitions. Pi reference code: ~/Code/badlogic/pi-mono/packages/agent/src/ (agent-loop.ts, types.ts, tools/).",
      "priority": 8,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "All 6 tools defined with proper schemas",
        "Tools return split output/details",
        "remember tool stores encrypted memory",
        "message tool delivers to target agent DO",
        "set_goal tool updates agent config",
        "think_aloud broadcasts via WebSocket only",
        "Tests for each tool"
      ]
    },
    {
      "id": "story-mlde2raq",
      "title": "Agent creation API",
      "description": "GitHub Issue #56. API endpoint to create new agents with full config. Add POST /agents route in apps/network/src/index.ts that: 1) Validates AgentConfig schema (name required, personality required, model defaults to moonshotai/kimi-k2.5). 2) Creates DO instance using env.AGENT.idFromName(name). 3) Forwards config to DO which stores it. 4) DO starts alarm chain (first alarm = now). 5) Returns agent identity (DID, public keys, config). Add GET /agents route that lists all known agents (query D1 for registered agents or maintain a registry). Handle duplicate names (409 Conflict). Handle invalid config (400 with validation errors). Auth required (ADMIN_TOKEN bearer). Update the existing agent creation flow (currently agents are created implicitly on first request to /agents/{name}/identity).",
      "priority": 9,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "POST /agents creates agent with config",
        "Agent starts looping immediately after creation",
        "GET /agents lists all agents",
        "409 on duplicate name",
        "400 on invalid config",
        "Auth required",
        "Tests for creation flow"
      ]
    },
    {
      "id": "story-mlde2zb2",
      "title": "Dashboard: agent thoughts, goals, loop activity",
      "description": "GitHub Issue #57. Enhance highswarm.com dashboard (packages/dashboard/index.html) to show real agent activity. 1) Agent detail view: click agent card to expand and show current goals with status indicators, recent think_aloud output, memory count, loop status (last alarm time, next alarm, iteration count), model being used, personality snippet. 2) Live activity feed improvements: show tool calls with structured details (not just raw text), show goal updates, show inter-agent messages with sender/recipient, show think_aloud entries styled differently (italic/dimmed â€” internal thought). 3) Fetch agent config from GET /agents/{name}/config and display. 4) Show loop heartbeat indicator (pulsing when alarm is active). Keep the existing dark theme and monospace aesthetic. Mobile responsive.",
      "priority": 10,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm --filter dashboard build && pnpm typecheck",
      "acceptanceCriteria": [
        "Agent cards expand to show detail view",
        "Goals displayed with status",
        "think_aloud visible in feed",
        "Tool call details shown",
        "Loop heartbeat indicator works",
        "Dashboard builds successfully",
        "Mobile responsive"
      ]
    },
    {
      "id": "story-mlde37m4",
      "title": "Self-extending agents (R2 extension storage)",
      "description": "GitHub Issue #58. Enable agents to write their own Pi extensions stored in R2. 1) Add write_extension tool: agent provides extension name and code, stored in R2 under extensions/{agentName}/{extensionName}.js. 2) Add load_extensions() method in AgentDO: on initialize(), list R2 objects under extensions/{agentName}/, load each as a module. Extensions export an activate(agent) function that can register additional tools. 3) Extension hot-reload: after write_extension, mark that extensions need reload on next alarm cycle. 4) Add list_extensions tool: shows what extensions the agent has. 5) Add remove_extension tool: deletes from R2. 6) Safety limits: max 10 extensions per agent, max 50KB per extension, no eval() â€” use structured tool registration only. 7) Bootstrap: on first loop, if agent has no extensions, provide a hint in the system prompt about self-extension capability. This is the Pi philosophy: agents extend themselves rather than downloading skills.",
      "priority": 11,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "write_extension stores code in R2",
        "Extensions load on DO init",
        "Hot-reload works after writing",
        "list_extensions and remove_extension work",
        "Safety limits enforced",
        "Tests for extension lifecycle"
      ]
    },
    {
      "id": "story-mlepdwd0",
      "title": "Wire environment hooks into agent alarm cycle",
      "description": "GH Issue #71. Replace the Catan-specific touchpoints in agent.ts with generic environment hooks.\n\n1. **observe()** â€” After collecting inbox/events, iterate over agent's enabled environments via the registry in `apps/network/src/environments/`. Call `env.buildContext(ctx)` for each. Append returned context strings to observations.\n\n2. **act() assist mode** â€” After model tool execution, if no environment-specific action was taken, iterate enabled environments and call `env.getAutoPlayActions(ctx)`. Inject returned tool calls. The current inline D1 game query and assist injection should be delegated to the CatanEnvironment.\n\n3. **buildTools()** â€” Call `env.getTool(ctx)` for each enabled environment and merge into the tool set. The inline game tool definition should move to `environments/catan.ts`.\n\n4. Agent config: Add `enabledEnvironments?: string[]` to the agent config type. If present, only load those environments. This replaces checking for 'game' in enabledTools for Catan.\n\n5. Create an `EnvironmentContext` from the agent's state (name, did, DB, relay, broadcast function) and pass it to environment methods.\n\nThe result: agent.ts has ZERO Catan-specific code. All game logic lives in environments/catan.ts.\n\nIMPORTANT: The environment files already exist at `apps/network/src/environments/` â€” types.ts, registry.ts, catan.ts, builtins.ts. Use them. The current Catan game tool definition (~line 2100-2150 in agent.ts) and assist mode logic (~line 993-1080 in agent.ts) and think prompt game context (~line 730-800 in agent.ts) need to move into the CatanEnvironment class methods.",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "No Catan-specific code in agent.ts",
        "observe delegates context building to environments",
        "act assist mode delegates to environments",
        "buildTools includes environment tools",
        "enabledEnvironments config option works",
        "All existing tests still pass"
      ]
    },
    {
      "id": "story-mlepe0v2",
      "title": "Environment HTTP API + backward compat",
      "description": "GH Issue #72. Update HTTP routing in `apps/network/src/index.ts` to support environments.\n\n1. `GET /environments` â€” list all environment instances. Supports query params: `?type=catan`, `?phase=playing`, `?player=grimlock`. Queries `games` table.\n2. `GET /environments/:id` â€” get specific environment instance with full state.\n3. `POST /environments` â€” create new environment instance. Body: `{ type: 'catan', players: ['slag', 'snarl'] }`. Delegates to the registered environment's creation logic.\n4. **Backward compat**: Keep existing `/games` and `/games/:id` routes working as aliases that filter to `type=catan`.\n5. Add environment type to the response objects.\n\nTests: verify /environments endpoints return correct data, verify /games still works.",
      "priority": 2,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "GET /environments returns environment list",
        "GET /environments/:id returns full state",
        "Query params filter by type and phase",
        "/games routes still work as aliases",
        "At least 2 endpoint tests"
      ]
    },
    {
      "id": "story-mlepe7gy",
      "title": "RPG dungeon crawl environment â€” BRP engine + AgentEnvironment",
      "description": "GH Issue #73. Second environment plugin â€” BRP-inspired RPG dungeon crawl.\n\n1. Create `apps/network/src/games/rpg-engine.ts` â€” pure game logic (no network deps):\n   - d100 skill resolution (roll under skill value = success)\n   - 4 classes: Warrior (STR), Scout (DEX), Mage (INT), Healer (WIS)\n   - Combat: initiative by DEX, attack vs dodge opposed roll\n   - Experience: successful skill checks improve that skill (BRP-style)\n   - Dungeon: rooms with encounters (combat, trap, treasure, rest, puzzle)\n   - Party-based: agents form party, take turns choosing actions\n\n2. Create `apps/network/src/environments/rpg.ts` implementing AgentEnvironment interface from `environments/types.ts`:\n   - `type: 'rpg'`, `label: 'Dungeon Crawl'`\n   - `getTool()` â€” rpg tool with commands: create_character, explore, attack, cast_spell, use_skill, rest, status\n   - `buildContext()` â€” current room, party health, available actions\n   - `getAutoPlayActions()` â€” if in combat: attack. If exploring: move to next room.\n\n3. Register RPGEnvironment in `environments/builtins.ts`.\n4. Store RPG state in `games` table with a different type field.\n\nTests: at least 8 tests covering skill checks, combat, experience gain, character creation.",
      "priority": 3,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "RPG engine handles d100 skill resolution",
        "4 classes with distinct stat spreads",
        "Combat system works with opposed rolls",
        "Experience improves skills on success",
        "RPGEnvironment implements AgentEnvironment",
        "At least 8 tests for RPG engine"
      ]
    },
    {
      "id": "story-mlepebbr",
      "title": "Dashboard: environment panel per agent",
      "description": "GH Issue #74. Add environment state display to the dashboard at `packages/dashboard/src/index.html`.\n\nWhen viewing agent detail:\n1. Fetch `GET /environments?player={agentName}` to get active environments\n2. Show environment cards: type icon, label, phase, other players, VP/HP summary\n3. For Catan: show board summary (settlements, roads, resources, VP)\n4. For RPG: show character sheet (class, HP, skills, current room)\n5. Expandable detail view with full state\n\nThe dashboard is vanilla HTML/JS, no framework. Use fetch() and DOM manipulation.",
      "priority": 4,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "Dashboard shows environment cards per agent",
        "Catan state rendered with board summary",
        "RPG state rendered with character sheet",
        "Fetches from /environments API",
        "Types pass"
      ]
    },
    {
      "id": "story-mlerh2h4",
      "title": "Stalemate detection â€” end Catan games early when stuck",
      "description": "Add stalemate detection to the Catan game engine. If no player has built anything (settlement or road) for N consecutive turns (suggest N=20), end the game early with the current point leader as winner.\n\nImplementation:\n1. Add `staleTurns` counter to game state (incremented on end_turn, reset to 0 when any player builds a settlement or road)\n2. In the `end_turn` action handler in `apps/network/src/games/catan.ts`, check if `staleTurns >= STALEMATE_THRESHOLD` (20). If so, set phase='finished', determine winner by highest points, set `winner` field.\n3. Add a `stalemate` field to the game-over result so agents/dashboard know it ended by stalemate vs normal victory.\n4. Write integration tests: game with forced stalemate scenario triggers early end, counter resets on build.\n\nFiles: `apps/network/src/games/catan.ts`, `apps/network/src/games/__tests__/catan.test.ts`",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo test --filter=network"
    },
    {
      "id": "story-mlerl07f",
      "title": "Agent factory o11y â€” full think prompt, loop transcript, and timing",
      "description": "Add comprehensive observability to the agentic tool loop in agent-factory.ts and expose it via the debug endpoint.\n\nThree things to instrument:\n\n1. **Full think prompt storage** â€” Store the complete messages array sent to OpenRouter in DO storage at `debug:lastPrompt`. Include system prompt + conversation history + tool definitions. Truncate if >100KB but preserve the system prompt and last 3 messages minimum. Expose via GET /agents/:name/debug as `lastPrompt`.\n\n2. **Agentic loop transcript** â€” In the multi-turn tool loop in `prompt()` (agent-factory.ts), record each step as an array entry:\n   ```ts\n   interface LoopStep {\n     step: number;\n     timestamp: number;\n     durationMs: number;\n     modelResponse?: { role: string; content?: string; toolCalls?: any[] };\n     toolResults?: { name: string; durationMs: number; result: any }[];\n   }\n   ```\n   Store the full transcript array in DO storage at `debug:loopTranscript`. Expose via GET /agents/:name/debug as `loopTranscript`.\n\n3. **Timing per step** â€” Each model call and each tool execution gets `performance.now()` before/after. Total loop duration stored at `debug:loopDurationMs`.\n\nImplementation notes:\n- All debug data written to DO storage via `this.state.storage.put()` in agent.ts after the think/act cycle completes\n- The factory `prompt()` method should return the transcript alongside the existing response (add it to the return value or store on the factory instance)\n- Debug endpoint in index.ts already reads from DO storage â€” extend it to include new fields\n- Keep backward compat â€” existing debug fields (lastThinkRaw, lastOpenRouterReq, autoPlay) remain\n\nFiles: `apps/network/src/agent-factory.ts`, `apps/network/src/agent.ts`, `apps/network/src/index.ts`, `apps/network/src/agent-do.test.ts`\n\nAcceptance criteria:\n- GET /agents/:name/debug returns lastPrompt (messages array), loopTranscript (step array with timing), loopDurationMs\n- Each tool execution in the loop has its own durationMs\n- Existing debug fields still present",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo test --filter=network"
    },
    {
      "id": "story-mlfbgtwo",
      "title": "Fix Vectorize embedding dimension mismatch (768 â†’ 1024)",
      "description": "The search tool returns VECTOR_QUERY_ERROR: expected 1024 dimensions, got 768. Switch embedding model to bge-large-en-v1.5 (1024D) or recreate index. Test dimensions match. Files: apps/network/src/agent.ts, apps/network/wrangler.toml. IMPORTANT: Include \"Closes #76\" in your commit message body.",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbgyyr",
      "title": "Goal lifecycle â€” prune completed goals, cap prompt bloat",
      "description": "Agents accumulate completed goals forever (slag has 7, 5 completed). Max 2 recent completed in prompt, archive rest in DO storage. Add maxCompletedGoals config. Files: apps/network/src/agent.ts, apps/network/src/agent-factory.ts. IMPORTANT: Include \"Closes #77\" in your commit message body.",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbh5sv",
      "title": "Enforce enabledTools strictly",
      "description": "Filter tool definitions sent to OpenRouter to ONLY include tools in agent enabledTools config. Snarl called recall/search which aren't in its config. If enabledTools empty, expose all (backward compat). Files: apps/network/src/agent-factory.ts, apps/network/src/agent.ts. IMPORTANT: Include \"Closes #78\" in your commit message body.",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhaur",
      "title": "Smarter error backoff â€” tiered by error type",
      "description": "Implement tiered backoff: transient (model timeout, rate limit) 15sâ†’30sâ†’60s cap. Persistent (config) 60sâ†’120sâ†’300s. Game-context 15s cap. Reset on success. Log error category. Files: apps/network/src/agent.ts. IMPORTANT: Include \"Closes #79\" in your commit message body.",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhfmx",
      "title": "Clear stale game state on completion",
      "description": "When game ends, mark goals referencing that gameId as completed. Inject game-over observation. Next observe cycle should present clean slate. Files: apps/network/src/agent.ts, apps/network/src/catan/. IMPORTANT: Include \"Closes #80\" in your commit message body.",
      "priority": 5,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhk80",
      "title": "Fix /games API â€” return all games",
      "description": "/games returns empty array despite games existing in D1. Fix the list query. Include active and recently finished (24h). Add pagination. Files: apps/network/src/index.ts. IMPORTANT: Include \"Closes #81\" in your commit message body.",
      "priority": 6,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhphy",
      "title": "Structured JSON logging for all agent lifecycle events",
      "description": "Add structured console.log JSON events: agent.cycle.start/end, agent.tool.call/result, agent.error, agent.goal.update, agent.game.action/end, agent.model.fallback, agent.alarm.schedule. Create apps/network/src/logger.ts utility. Foundation for Cloudflare Pipelines. Files: apps/network/src/logger.ts (new), apps/network/src/agent-factory.ts, apps/network/src/agent.ts. IMPORTANT: Include \"Closes #82\" in your commit message body.",
      "priority": 7,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhwfc",
      "title": "Fix autoPlay â€” filter by game type and skip finished/abandoned games",
      "description": "In apps/network/src/agent.ts around line 908, the game detection query is:\\n  SELECT id, type, state FROM games WHERE phase IN ('playing', 'setup') AND players LIKE ?\\n\\nProblem: It also needs to skip games with phase='finished' or 'abandoned' that linger. And the autoPlay safety debug (stored at debug:autoPlay around line 1245) doesn't record the game type.\\n\\nFix:\\n1. In the game query (~line 908), add `AND phase NOT IN ('finished', 'abandoned', 'cancelled')` (belt and suspenders with the existing IN clause)\\n2. In the autoPlay debug object (~line 1245), add `gameType` field from gameRow.type\\n3. Add a test in agent-do.test.ts: mock a finished game in DB, verify observe() does NOT inject game context\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 8,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbi0o4",
      "title": "Adaptive alarm interval â€” faster when it's your turn in a game",
      "description": "In apps/network/src/agent.ts, the alarm() method sets intervalMs from config (~line 530). After the observe phase builds gameContext, we know if it's the agent's turn.\\n\\nAdd logic after the game context block (~line 1090):\\n1. If gameContext contains 'ðŸŽ®ðŸŽ®ðŸŽ® IT IS YOUR TURN', set intervalMs = Math.min(intervalMs, 15000)\\n2. If gameContext contains 'ðŸŽ² Active' (waiting for another player), set intervalMs = Math.min(intervalMs, 45000)\\n3. Store the interval reason in the autoPlay debug: `intervalReason: 'my_turn' | 'waiting' | 'default'`\\n\\nAdd a test: mock isMyTurn=true game state, verify alarm reschedules with 15s interval.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 9,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbi54u",
      "title": "Post-game summary â€” log structured outcome when game finishes",
      "description": "In apps/network/src/environments/catan.ts, when a game ends (phase becomes 'finished'), emit a structured summary. Find the code that sets phase='finished' (search for `phase = 'finished'` or `phase: 'finished'`).\\n\\nAfter setting phase to finished:\\n1. Build a summary object: { gameId, type: 'catan', winner, turns: state.turn, players: state.players.map(p => ({name: p.name, vp: p.victoryPoints})) }\\n2. console.log(JSON.stringify({ event_type: 'game.completed', level: 'info', ...summary }))\\n\\nDo the same in apps/network/src/environments/rpg.ts for RPG game completion.\\n\\nAdd a test in each environment's test file: complete a game, verify the JSON log line contains event_type='game.completed'.\\n\\nFiles: apps/network/src/environments/catan.ts, apps/network/src/environments/rpg.ts, apps/network/src/environments/catan.test.ts (or rpg.test.ts)\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 10,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedqnm",
      "title": "Add AlarmMode enum and mode rotation to agent config",
      "description": "GH Issue #87.\\n\\nIn apps/network/src/agent.ts:\\n1. Add a type near the top: `type AlarmMode = 'think' | 'housekeeping' | 'reflection'`\\n2. In alarm() (~line 498), read current mode from DO storage: `const mode = await this.ctx.storage.get<AlarmMode>('alarmMode') ?? 'think'`\\n3. After the main cycle completes (before rescheduling the alarm, ~line 730), rotate mode:\\n   - If mode was 'think' for 5+ consecutive cycles, set next mode to 'housekeeping'\\n   - If mode was 'housekeeping', set next to 'reflection'\\n   - If mode was 'reflection', set next to 'think' and reset counter\\n   - Store: `await this.ctx.storage.put('alarmMode', nextMode)` and `await this.ctx.storage.put('alarmModeCounter', counter)`\\n4. For now, ALL modes still run the same observeâ†’thinkâ†’actâ†’reflect cycle. Later stories will add mode-specific behavior.\\n\\nAdd test: run alarm() 7 times, verify mode rotates think(5)â†’housekeeping(1)â†’reflection(1)â†’think.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 11,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedrp4",
      "title": "Store ActionOutcome after each tool call in act()",
      "description": "GH Issue #91.\\n\\nIn apps/network/src/agent.ts, find the act() method (~line 1212). Inside the tool execution loop (where it iterates over thought.toolCalls), after each tool result is received:\\n\\n1. Define type ActionOutcome = { tool: string, success: boolean, timestamp: number, goalId?: string }\\n2. After each tool call completes, push an ActionOutcome to a rolling buffer\\n3. Store the buffer in DO storage: `await this.ctx.storage.put('actionOutcomes', outcomes.slice(-50))`\\n4. In the reflect phase (~search for 'reflect'), read the outcomes and include the last 5 in the reflection prompt so the agent can learn from recent actions\\n\\nAdd test: run alarm() with tool calls, verify actionOutcomes is stored in DO storage with correct tool names.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 12,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedsg1",
      "title": "Add extension tools to all agents' default enabledTools",
      "description": "GH Issue #90.\\n\\nIn apps/network/src/agent.ts, find where enabledTools is read from config (~search for 'enabledTools'). There should be a default list.\\n\\n1. Add 'write_extension', 'list_extensions', 'remove_extension' to the default enabledTools array (alongside game, think_aloud, remember, recall, message, etc.)\\n2. In the system prompt builder (~line 1100), if extension tools are enabled, append a short hint: 'You can create extensions with write_extension to add new capabilities.'\\n3. Verify the extension tools already have implementations (search for 'write_extension' in agent.ts) â€” they should exist from previous work. If not, skip this and just add to defaults.\\n\\nAdd test: create agent with default config, verify enabledTools includes write_extension.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 13,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedt6k",
      "title": "Housekeeping mode â€” prune old goals and stale memories",
      "description": "GH Issue #88. Depends on AlarmMode being added (story-mlfedqnm).\\n\\nIn apps/network/src/agent.ts:\\n1. Add a private method `async runHousekeeping()` that:\\n   a. Reads goals from config, removes any with status='completed' that are older than 24h\\n   b. Reads actionOutcomes from storage, trims to last 50\\n   c. Logs: console.log(JSON.stringify({ event_type: 'agent.housekeeping', level: 'info', prunedGoals: count, trimmedOutcomes: count }))\\n2. In alarm(), when alarmMode === 'housekeeping', call runHousekeeping() INSTEAD of the normal observeâ†’thinkâ†’actâ†’reflect cycle\\n3. Still reschedule the next alarm as normal\\n\\nAdd test: set alarmMode='housekeeping' in storage, add 3 completed goals older than 24h, run alarm(), verify goals were pruned.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 14,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedtxx",
      "title": "Reflection mode â€” self-assessment from recent action outcomes",
      "description": "GH Issue #89. Depends on AlarmMode and ActionOutcome stories.\\n\\nIn apps/network/src/agent.ts:\\n1. Add a private method `async runReflection()` that:\\n   a. Reads last 10 actionOutcomes from DO storage\\n   b. Builds a reflection prompt: 'Review your last 10 actions. What patterns do you see? What should you do differently? Respond with updated goals if needed.'\\n   c. Calls the AI provider with this prompt (reuse the existing think/prompt pattern)\\n   d. If the response includes goals, update them in config\\n   e. Stores the reflection text in DO storage key 'lastReflection'\\n2. In alarm(), when alarmMode === 'reflection', call runReflection() INSTEAD of normal cycle\\n\\nAdd test: set alarmMode='reflection', add actionOutcomes, run alarm(), verify lastReflection is stored.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 15,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedukk",
      "title": "Track extension usage metrics in DO storage",
      "description": "GH Issue #92.\\n\\nIn apps/network/src/agent.ts, find where extensions are executed (search for 'write_extension' or 'executeExtension'). After an extension runs:\\n\\n1. Define type ExtensionMetrics = { name: string, totalCalls: number, successCalls: number, failedCalls: number, lastUsed: number }\\n2. After extension execution, read metrics from DO storage key `extensionMetrics:${name}`, increment counters, write back\\n3. In the GET /debug endpoint, include extension metrics in the response\\n\\nAdd test: execute an extension tool, verify extensionMetrics is stored with correct counts.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 16,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedv85",
      "title": "Add Cloudflare Pipeline binding for o11y event streaming",
      "description": "GH Issue #93.\\n\\nThis story adds the Pipeline binding to wrangler.toml and a helper to send events. The pipeline itself is created via `wrangler pipelines create agent-o11y`.\\n\\n1. In apps/network/wrangler.toml, add under [pipelines]:\\n   ```\\n   [[pipelines]]\\n   binding = \\\"O11Y_PIPELINE\\\"\\n   pipeline = \\\"agent-o11y\\\"\\n   ```\\n2. In apps/network/src/agent.ts, add the binding to the Env interface: `O11Y_PIPELINE?: { send(events: unknown[]): Promise<void> }`\\n3. Create a helper function `sendO11yEvent(pipeline: unknown, event: Record<string, unknown>)` that calls pipeline.send([event]) with try/catch (non-fatal)\\n4. Call sendO11yEvent at the end of alarm() with a cycle summary: { event_type: 'agent.cycle', agent, mode, durationMs, toolCalls: count, errors: count }\\n\\nDO NOT create the pipeline â€” just add the binding and code. Tests should mock the pipeline binding.\\n\\nFiles: apps/network/wrangler.toml, apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 17,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedvzt",
      "title": "Admin analytics endpoint â€” GET /admin/analytics with cycle stats",
      "description": "GH Issue #94.\\n\\nAdd a new admin endpoint that returns agent analytics from DO storage (not R2/Parquet yet â€” that comes after Pipelines are live).\\n\\n1. In apps/network/src/index.ts, add route `GET /admin/analytics` (behind admin auth)\\n2. For each agent DO, read: loopCount, consecutiveErrors, alarmMode, actionOutcomes (last 10), extensionMetrics, lastReflection\\n3. Return JSON: { agents: [{ name, loopCount, errors, mode, recentActions: [...], extensions: [...] }] }\\n4. If the DO values don't exist yet (features not deployed), return null/empty for those fields\\n\\nAdd a test in the appropriate test file: call GET /admin/analytics, verify it returns the expected shape.\\n\\nFiles: apps/network/src/index.ts, apps/network/src/index.test.ts (or agent-factory.test.ts)\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 18,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm67k3",
      "title": "Cooperative dungeon generator â€” longer dungeons with class-gated rooms",
      "description": "Replace `defaultDungeon()` in `apps/network/src/games/rpg-engine.ts` with `generateDungeon(depth: number)` that creates 10-15 room procedural dungeons.\n\n**New room types to add to Room union (lines 58-63):**\n- `{ type: 'boss'; description: string; enemies: Enemy[] }` â€” high-HP boss\n- `{ type: 'barrier'; description: string; requiredClass: RpgClass }` â€” class-gated\n\n**Add `generateDungeon(depth, dice)` function:**\n- Creates `depth` rooms (default 12)\n- 4 barriers (one per class) spread throughout\n- Boss in final room (30+ HP enemy)\n- Mix of combat/trap/treasure/rest/puzzle between barriers\n- Scale enemy HP: early 6-8, mid 10-14, boss 30+\n- Update `defaultDungeon()` to call `generateDungeon(12, createDice())`\n- Export generateDungeon\n\n**Tests in `rpg-engine.test.ts`:** room count, all 4 barriers present, boss last room, HP scaling\n\nCloses #100",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm687r",
      "title": "Role synergy â€” heal-other, taunt, AoE, trap-disarm",
      "description": "Add class-specific cooperative abilities.\n\n**`apps/network/src/games/rpg-engine.ts`:**\n1. `healOther(game, {healer, target, dice})` â€” 1 MP, cast_spell check, heals d6+WIS/20\n2. `taunt(game, {taunter, dice})` â€” use_skill check, adds taunted_by to Enemy type\n3. `aoeSpell(game, {caster, dice})` â€” 2 MP, cast_spell, d4 to ALL enemies\n4. `disarmTrap(game, {scout, dice})` â€” use_skill +15 bonus\n\n**`apps/network/src/environments/rpg.ts`:**\n5. Add `heal`, `taunt`, `aoe`, `disarm` commands + handlers\n6. Update tool description\n\n**Tests in rpg-engine.test.ts** for each ability",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm68ug",
      "title": "Barrier rooms â€” class-gated progression",
      "description": "Barriers block progression without the required class.\n\n**`apps/network/src/games/rpg-engine.ts`:**\n1. `explore()`: barrier rooms check party for matching klass, set mode='blocked' if missing\n2. Add 'blocked' to RpgMode\n3. `resolveBarrier(game)` export â€” checks if barrier clearable, resets to exploring\n\n**`apps/network/src/environments/rpg.ts`:**\n4. `create_character`: call resolveBarrier after adding\n5. `buildContext()`: blocked â†’ \"â›” BLOCKED: requires {class}. Message other agents!\"\n6. `getAutoPlayActions()`: empty when blocked\n\n**Tests:** blocks without class, resolves when class joins",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm69gm",
      "title": "Party formation â€” join existing games instead of solo",
      "description": "**`apps/network/src/environments/rpg.ts`:**\n1. Add `join_game` command â€” gameId+klass, adds to party\n2. `new_game`: check for open RPG <3 players, suggest joining\n3. `buildContext()`: no active game â†’ show joinable games\n4. `getAutoPlayActions()`: no game but joinable â†’ return join_game\n\n**Tests:** join adds to party, new_game suggests joining",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm6a4e",
      "title": "Solo penalty â€” double damage when alone",
      "description": "**`apps/network/src/games/rpg-engine.ts`:**\n1. `soloMultiplier(partySize)` â€” 1p:2.0, 2p:1.5, 3+:1.0\n2. Trap damage Ã— soloMultiplier in explore()\n3. `partyWipe(game)` â€” all hp<=0 â†’ finished\n4. Call partyWipe after damage events\n\n**`apps/network/src/environments/rpg.ts`:**\n5. Combat: enemy counter-attacks, damage Ã— soloMultiplier\n\n**Tests:** multiplier values, solo double damage, party wipe",
      "priority": 5,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm6apo",
      "title": "Cooperation prompts â€” teach agents to work together",
      "description": "**`apps/network/src/agent.ts`:**\n1. In buildThinkPrompt RPG section, add COOPERATION RULES: never solo, join parties, healers heal, warriors taunt, scouts disarm, mages AoE\n2. Blocked mode: \"URGENT: Recruit {requiredClass} via message tool\"\n\n**Tests in agent-do.test.ts:** cooperation rules in prompt, blocked adds recruitment msg",
      "priority": 6,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo24tb",
      "title": "D1 schema: generic games table for environment state",
      "description": "GH Issue #110. ONLY touch these 3 files â€” nothing else:\n\nFILE 1: apps/network/schema.sql â€” Add this EXACT SQL at the end:\nCREATE TABLE IF NOT EXISTS games (id TEXT PRIMARY KEY, type TEXT, host_agent TEXT, state TEXT, phase TEXT, players TEXT, winner TEXT, created_at TEXT, updated_at TEXT);\n\nFILE 2: apps/network/src/schema.test.ts â€” Add a test that the 'games' table exists with the correct columns. Follow existing patterns in this file.\n\nFILE 3: packages/core/src/d1-mock.ts â€” Add the same CREATE TABLE statement to the mock DB init so tests use it.\n\nCRITICAL: Do NOT touch ANY other files. No dashboard, no rpg-engine, no index.ts, no CSS, no HTML. THREE FILES ONLY: schema.sql, schema.test.ts, d1-mock.ts.\n\nCloses #110",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo25hl",
      "title": "Environment runtime: drive context + autoplay via AgentEnvironment registry",
      "description": "GH Issue #109. Refactor AgentDO so environment-specific logic is NOT hardcoded in agent.ts.\n\nFind hardcoded env logic: rg -n \"SAFETY NET\" apps/network/src/agent.ts\n\nReplace with registry dispatch: AgentDO calls environment hooks from registry (buildContext, isActionTaken, getAutoPlayActions) instead of if/else branching.\n\nFiles to modify: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts, apps/network/src/environments/types.ts (if needed)\n\nThis is a REFACTOR â€” behavior must be identical. All 217+ existing tests must pass.\n\nCloses #109",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo266m",
      "title": "RalphEnvironment: skeleton environment + tool + tests",
      "description": "GH Issue #112. New files: apps/network/src/environments/ralph.ts, apps/network/src/environments/ralph.test.ts. Modify: apps/network/src/environments/builtins.ts.\n\nImplement AgentEnvironment for 'ralph' type. Tool 'ralph' with commands 'help' and 'status'. Register in builtins.ts. Tests for registry lookup, tool commands, buildContext, isActionTaken.\n\nReference: rpg.ts and catan.ts for the pattern.\n\nCloses #112",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo26t9",
      "title": "Ralph backlog: generic work_items queue + ralph tool commands",
      "description": "GH Issue #113. Add work_items table to schema.sql and d1-mock.ts:\nCREATE TABLE IF NOT EXISTS work_items (id TEXT PRIMARY KEY, env_type TEXT NOT NULL, env_id TEXT, status TEXT NOT NULL DEFAULT 'open', priority INTEGER NOT NULL DEFAULT 0, title TEXT NOT NULL, payload_json TEXT NOT NULL DEFAULT '{}', claimed_by_did TEXT, claimed_at TEXT, created_at TEXT NOT NULL, updated_at TEXT NOT NULL);\n\nExtend ralph tool in ralph.ts with commands: propose_work, claim_work, submit_result, status.\n\nTests in ralph.test.ts for propose/claim/submit/status flows.\n\nCloses #113",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo27gl",
      "title": "Ralph autoplay: agents claim queued work items",
      "description": "GH Issue #111. Implement getAutoPlayActions() in ralph.ts: when no other env action was taken and there's an open work_items row, return a claim action. Query: SELECT * FROM work_items WHERE env_type='ralph' AND status='open' ORDER BY priority ASC LIMIT 1.\n\nFiles: apps/network/src/environments/ralph.ts, apps/network/src/agent.ts (if needed), agent-do.test.ts.\n\nCloses #111",
      "priority": 5,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5kxr",
      "title": "Auto-restart games on completion â€” Grimlock creates new coop dungeon",
      "description": "GH Issue #98. When an RPG game finishes, Grimlock should auto-create a new coop dungeon.\n\nIMPLEMENTATION in apps/network/src/environments/rpg.ts:\n- In the RPG tool handler, after detecting game phase='finished' (or when explore() returns phase='finished'), emit a \"game complete\" event\n- Add a post-game hook: when the game finishes AND the agent is grimlock, auto-create a new game after a short delay\n- OR: in the autoplay/buildContext, if grimlock has no active game and there are no playing games, include a directive to create one\n\nSIMPLER APPROACH: In apps/network/src/agent.ts or rpg.ts buildContext(), detect \"no active playing games in D1\" and if agent is grimlock, add context saying \"No active dungeon. Create one with rpg new_game.\"\n\nAdd maxGamesPerDay config (default 50) â€” count finished games today in D1, stop creating if limit hit.\n\nFiles: apps/network/src/environments/rpg.ts, apps/network/src/environments/rpg.test.ts\nValidation: pnpm typecheck && pnpm test\n\nCloses #98",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5llk",
      "title": "Grimlock inbox webhook bridge â€” POST messages to webhookUrl",
      "description": "GH Issue #99. When /inbox receives a message and agent config has a webhookUrl field, POST the message payload to that URL. Fire-and-forget, no retries.\n\nFiles: apps/network/src/agent.ts (inbox handler), apps/network/src/agent-do.test.ts\n\nFind the inbox handler: grep -n 'inbox' apps/network/src/agent.ts\n\nAdd to AgentConfig type: webhookUrl?: string\n\nIn the inbox handler, after storing the message, check if config.webhookUrl is set. If so:\n```typescript\nif (this.config?.webhookUrl) {\n  fetch(this.config.webhookUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ type: 'inbox', message: incomingMessage }),\n  }).catch(() => {}) // fire and forget\n}\n```\n\nTest: mock fetch, send inbox message with webhookUrl configured, assert fetch was called with correct payload.\n\nCloses #99",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5m7k",
      "title": "Suppress think_aloud/recall during active game turns",
      "description": "GH Issue #97. During active game turns (isMyTurn=true), remove think_aloud and recall from the tool definitions sent to the LLM so agents focus on game actions.\n\nFind where tools are filtered: grep -n 'enabledTools\\|toolDefinitions\\|buildTools' apps/network/src/agent.ts apps/network/src/agent-factory.ts\n\nIMPLEMENTATION: In the agent factory or tool-building step, when the agent has an active game and it's their turn, filter out think_aloud and recall from the tool list. They can still use remember.\n\nAdd o11y log when suppressing: { event_type: 'tools.gameplay_filter', suppressed: ['think_aloud', 'recall'] }\n\nFiles: apps/network/src/agent.ts or apps/network/src/agent-factory.ts, apps/network/src/agent-do.test.ts\nValidation: pnpm typecheck && pnpm test\n\nCloses #97",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5mua",
      "title": "Tool router â€” remap gameâ†”rpg calls based on active environment",
      "description": "GH Issue #95. When an agent calls the wrong tool (game in RPG context or rpg in Catan context), remap it to the correct tool instead of failing.\n\nFind where tool calls are executed: grep -n 'executeTool\\|handleToolCall\\|toolCall' apps/network/src/agent.ts | head -20\n\nIMPLEMENTATION: Before executing a tool call, check the agent's active environment:\n- If active env is RPG and tool called is 'game' â†’ remap to 'rpg'  \n- If active env is Catan and tool called is 'rpg' â†’ remap to 'game'\n- Log the remap as o11y event: { event_type: 'agent.tool.misroute', from: 'game', to: 'rpg', env: 'rpg' }\n\nThis should be a simple if/else before the tool dispatch switch.\n\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\nValidation: pnpm typecheck && pnpm test\n\nCloses #95",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfzhu6d",
      "title": "Phase 1a: Barrier class filtering â€” only generate barriers for party classes",
      "description": "In rpg-engine.ts generateDungeon(), barrier rooms currently pick random classes. Fix to only pick from classes actually present in the party. Read the party composition from game state before generating. If party has [Warrior, Mage], only generate warrior/mage barriers â€” never scout/healer barriers. This is the #1 softlock cause (82 consecutive \"barrier: blocked\" entries in logs).\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: barriers in generated dungeons only require classes present in the party. Add a test that generates 100 dungeons for a 2-class party and asserts no barrier requires a missing class.",
      "priority": 51,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzi29l",
      "title": "Phase 1b: Alternative paths for barriers â€” brute force, skill check, auto-crumble",
      "description": "When a party encounters a barrier they can't pass (wrong class), provide alternative paths instead of softlocking:\n\n1. **Brute force**: Any warrior-type can smash through at HP cost (lose 20% max HP)\n2. **Skill check**: INT or WIS check at Hard difficulty (30%) â€” any class can attempt\n3. **MP sacrifice**: Spend 50% max MP to magically force it open\n4. **Auto-crumble**: After 5 failed attempts on the same barrier, the GM narrates it crumbling (\"The ancient seal weakens and shatters\")\n\nIn rpg-engine.ts, modify the barrier action handler. When class doesn't match, instead of returning \"blocked\", offer alternatives and resolve them. Track attempt count per barrier in game state.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: A party without the required class can still pass any barrier via one of the 4 alternatives. Auto-crumble triggers after exactly 5 failed attempts. Test all 4 paths.",
      "priority": 52,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzi9ki",
      "title": "Phase 1c: Stuck detection â€” same action 5x triggers GM intervention",
      "description": "Track the last N actions per player in game state. If a player takes the exact same action 5 times in a row (same action type + same target), the game intervenes:\n\n1. Log a warning in the game log\n2. Auto-resolve the current obstacle (open the barrier, kill the enemy at HP cost, skip the puzzle)\n3. Add a narrative message: \"The dungeon shifts around you, opening a new path...\"\n4. Move the party forward one room\n\nThis prevents infinite loops where an agent keeps trying the same failing action. Store action history as an array of {action, target, roomIndex} in the game state.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: After 5 identical consecutive actions, the game auto-resolves and advances. Test with a mock agent repeating the same action.",
      "priority": 53,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzig0p",
      "title": "Phase 1d: Enemy scaling to party size",
      "description": "Scale combat encounters based on party size:\n\n- **Solo (1 player)**: Enemies at 60% HP, 60% damage (solo penalty already adds 2x damage taken, so enemies should be weaker)\n- **Duo (2 players)**: Enemies at 80% HP, 80% damage  \n- **Full party (3+ players)**: Enemies at 100% HP, 100% damage\n- **Boss rooms**: Scale boss HP by 50% per additional player beyond 1\n\nIn generateDungeon() and combat resolution, read party size and apply multipliers. Store the scaling factors in the dungeon state so they're visible in debug output.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Solo player faces weaker enemies than a full party. Boss HP scales with party size. Test with 1, 2, and 3 player parties and assert different enemy stats.",
      "priority": 54,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzioik",
      "title": "Phase 2a: Dungeon themes and narrative arc â€” replace random rooms with story",
      "description": "Replace the current random room generation with themed narrative dungeons. Add a dungeon theme system:\n\n1. Add a `theme` field to dungeon state with properties: name, backstory, atmosphere, and room_flavor_seeds\n2. Create 5-10 dungeon theme templates (e.g., \"The Whispering Mines\", \"Sunken Temple of the Drowned God\", \"The Clockwork Labyrinth\")\n3. Each theme defines: room description templates, enemy types that fit the theme, barrier flavors, boss identity\n4. Room descriptions should reference the theme and build narrative tension (early rooms = exploration/mystery, mid = rising threat, late = climax)\n5. Replace static \"a goblin prowls here\" descriptions with theme-aware text\n\nThe dungeon should feel like a story: setup â†’ rising action â†’ climax â†’ resolution.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Generated dungeons have a theme name and backstory. Room descriptions reference the theme. No more generic \"a goblin prowls here\" â€” all descriptions are thematic. Test that 10 generated dungeons each have unique themes.",
      "priority": 55,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfziw4w",
      "title": "Phase 2b: Room descriptions reference party actions â€” dynamic narrative",
      "description": "Make room descriptions and game log entries reference what the party has actually done. When entering a new room:\n\n1. Check the game log for notable events (kills, near-deaths, barriers overcome, items found)\n2. Weave references into the next room's description: \"Slag's fireball still echoes in the tunnels ahead\" or \"The blood from your last fight has attracted something...\"\n3. Add a `narrativeContext` array to game state that tracks key story beats\n4. Boss room description should reference the entire journey: callbacks to earlier rooms, items found, party members who nearly died\n\nThis makes the dungeon feel reactive, not static. The narrative should acknowledge the party's actual experience.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Room descriptions after room 3+ contain references to prior party actions. Boss room description references at least 2 earlier events. Test by simulating a full dungeon run and checking description content.",
      "priority": 56,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzj4xx",
      "title": "Phase 3a: GM tool â€” Grimlock-only tool for live dungeon adjudication",
      "description": "Create a new `gm` tool that only Grimlock can use. Actions:\n\n1. `narrate` â€” Add a narrative message to the game log (GM flavor text, descriptions, dramatic moments)\n2. `adjust_difficulty` â€” Modify a room's enemy stats, barrier difficulty, or add/remove hazards mid-dungeon\n3. `add_event` â€” Inject an emergent event into the current room (NPC encounter, environmental hazard, loot drop, plot twist)\n4. `review_party` â€” Get a summary of party status (HP, MP, inventory, rooms cleared, deaths, near-deaths)\n\nRegister the tool in the tool registry but ONLY enable it for grimlock agent config. Other agents should never see this tool.\n\nThe GM tool operates on active RPG games. It reads/writes to the same D1 game state that rpg-engine uses. Actions are logged in the game log with a [GM] prefix.\n\nFiles: apps/network/src/tools/gm-tool.ts (new), apps/network/src/tools/index.ts, apps/network/src/environments/rpg-engine.ts\n\nAcceptance: GM tool registered and callable. Only grimlock can use it (other agents get \"tool not available\"). narrate adds to game log, adjust_difficulty modifies room state, review_party returns party summary. Tests for each action + access control test.",
      "priority": 57,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzjdn8",
      "title": "Phase 3b: Dynamic difficulty scaling â€” GM auto-adjusts based on party performance",
      "description": "Add automatic difficulty adjustment logic that Grimlock's GM loop can trigger:\n\n1. **Track party performance metrics** in game state: average HP %, rooms cleared without rest, deaths, near-deaths (HP < 20%), overkill ratio (damage dealt vs enemy HP)\n2. **Difficulty signals**:\n   - Party breezing (avg HP > 80% after 3+ combat rooms) â†’ increase enemy damage by 20%, add extra enemies\n   - Party struggling (avg HP < 40%, or 2+ near-deaths) â†’ reduce next room difficulty, place a rest room, add healing loot\n   - Party TPK risk (any member dead + another < 30% HP) â†’ next room is a rest room with full heal\n3. **GM intervention hook**: After each room completion, calculate metrics and if adjustment needed, auto-call adjust_difficulty on upcoming rooms\n4. Log all adjustments in game log with [GM] prefix so it's observable\n\nFiles: apps/network/src/environments/rpg-engine.ts, apps/network/src/tools/gm-tool.ts\n\nAcceptance: Party performance is tracked. Difficulty adjusts automatically based on thresholds. A test simulating a struggling party gets easier rooms. A test simulating a breezing party gets harder rooms.",
      "priority": 58,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzjmrq",
      "title": "Phase 4a: consult_library GM action â€” pdf-brain integration for RPG knowledge",
      "description": "Add a `consult_library` action to the GM tool that queries pdf-brain for RPG knowledge. This runs LOCALLY on clanker-001 via Grimlock's webhook.\n\n1. Add `consult_library` action to gm-tool.ts that sends a webhook request to Grimlock's webhookUrl with a pdf-brain search query\n2. The webhook handler on clanker-001 (OpenClaw) runs `pdf-brain search \"<query>\" --limit 3 --expand 2000` and returns results\n3. GM can query for: encounter design patterns, monster tactics, skill check rulings, dungeon procedures, BRP mechanics\n4. Results are returned as text that the GM can use to inform narration and difficulty decisions\n5. Add a `libraryContext` field to game state where GM can cache relevant lookups for the current dungeon theme\n\nThe webhook bridge (story-mlft5llk) already exists. This extends it to handle pdf-brain queries as a new message type.\n\nFiles: apps/network/src/tools/gm-tool.ts, webhook handler on clanker-001 side\n\nAcceptance: GM tool can call consult_library with a query string and get pdf-brain results back. Test with a mock webhook that returns sample results. Integration test queries actual pdf-brain.",
      "priority": 59,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzjx9w",
      "title": "Phase 4b: GM-crafted dungeons â€” use library knowledge for encounter design",
      "description": "Replace the static generateDungeon() with a GM-driven dungeon crafting flow. When Grimlock creates an RPG game:\n\n1. Grimlock's loop calls `gm.craft_dungeon` instead of the static generator\n2. craft_dungeon first calls `consult_library` with queries like:\n   - \"encounter design pacing and difficulty curve\" (Game Angry)\n   - \"BRP opposed roll mechanics combat\" (BRP SRD)  \n   - \"monster tactics for [theme enemies]\" (Monsters Know)\n   - \"dungeon exploration procedures\" (OSE)\n3. Using library context + party composition, generate a dungeon with:\n   - Difficulty curve from Game Angry (easyâ†’mediumâ†’hardâ†’deadlyâ†’boss)\n   - BRP-informed combat mechanics (opposed rolls, crits at skill/5, fumbles at 96-00)\n   - Monster tactics per enemy type (goblins hit-and-run, orcs power attack, boss multi-phase)\n   - Strategic rest placement (after hard fights, not random)\n4. Store libraryContext in dungeon state for reference during live adjudication\n\nThis is where Grimlock becomes an actually knowledgeable GM instead of a random number generator.\n\nFiles: apps/network/src/tools/gm-tool.ts, apps/network/src/environments/rpg-engine.ts\n\nAcceptance: craft_dungeon queries pdf-brain and uses results to inform dungeon design. Enemy tactics vary by type. Difficulty follows Game Angry curve. Boss fights are multi-phase. Test that crafted dungeons reference library knowledge in their design.",
      "priority": 60,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlg25sjb",
      "title": "Fix: Skip dead players in turn order â€” don't assign turns to 0 HP players",
      "description": "Bug: When a party member dies (hp=0), the turn system still assigns them as currentPlayer, softlocking the game since dead agents can't take actions.\n\nFix in rpg-engine.ts turn advancement logic:\n1. When advancing to next player, skip any player with hp <= 0\n2. If ALL players are dead, end the game (TPK â€” total party kill)\n3. Remove dead players from the active turn rotation but keep them in party state (for potential resurrection mechanics later)\n4. When a player dies mid-combat, immediately advance to the next living player\n5. Add a log entry when skipping a dead player: \"[name] is dead, skipping turn\"\n\nThis was observed in production: swoop died at 0 HP but currentPlayer was still \"swoop\", freezing the game loop.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Dead players (hp=0) are never assigned as currentPlayer. If a player dies during combat, turn immediately advances to next living player. TPK (all dead) ends the game. Test with a party where one member dies mid-combat and verify turn skips them.",
      "priority": 55,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlg5qzc3",
      "title": "Phase 4b-1: craft_dungeon GM action â€” replace generateDungeon with GM-driven flow",
      "description": "Add a `craft_dungeon` action to the GM tool that Grimlock calls instead of the static generateDungeon(). \n\n1. Add `craft_dungeon` to gm-tool.ts with params: { gameId, theme?, partyComposition }\n2. It should read the party from game state (classes, stats, skills)\n3. Call the existing consult_library action internally with queries like \"encounter design pacing\" and \"BRP combat mechanics\"\n4. Store the library results in a `libraryContext` field on the dungeon state\n5. For now, still use generateDungeon() for the actual room layout but pass libraryContext so future stories can use it\n6. Return the crafted dungeon state\n\nThis is the plumbing â€” wire craft_dungeon into the flow without changing dungeon gen yet.\n\nFiles: apps/network/src/tools/gm-tool.ts, apps/network/src/tools/gm-tool.test.ts\n\nAcceptance: craft_dungeon action exists, reads party, calls consult_library, stores libraryContext. Test that craft_dungeon returns a dungeon with libraryContext populated.",
      "priority": 61,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlg5r7ew",
      "title": "Phase 4b-2: BRP-informed combat â€” opposed rolls, crits, fumbles",
      "description": "Upgrade combat resolution in rpg-engine.ts to use BRP-style mechanics:\n\n1. **Opposed rolls**: Attacker rolls against attack skill, defender rolls against dodge. Both succeed = compare margins. Both fail = miss.\n2. **Critical hits**: Roll <= skill/5 = double damage\n3. **Fumbles**: Roll 96-00 = bad thing happens (attacker hits self for half damage, or drops weapon losing next turn)\n4. **Damage calculation**: Base damage + STR bonus - armor (if any)\n\nReplace the current simple \"roll vs attack\" with these mechanics. Keep it deterministic enough to test.\n\nFiles: apps/network/src/games/rpg-engine.ts, apps/network/src/games/rpg-engine.test.ts\n\nAcceptance: Combat uses opposed rolls. Crits at skill/5 do double damage. Fumbles at 96+ cause self-harm. Tests for each mechanic with seeded random.",
      "priority": 62,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlg5rfww",
      "title": "Phase 4b-3: Monster tactics by enemy type â€” goblins, orcs, boss behaviors",
      "description": "Add enemy AI tactics to combat in rpg-engine.ts. Each enemy type should behave differently:\n\n1. **Goblins**: Hit and run â€” attack squishy targets (lowest HP or Mage class), flee at <30% HP\n2. **Orcs**: Aggressive â€” power attack (+10 damage, -10 hit chance), fight to the death\n3. **Skeleton**: Resistant to piercing, vulnerable to blunt. Target random.\n4. **Boss**: Multi-phase behavior:\n   - Phase 1 (>50% HP): Target healer first, use special ability every 3 turns\n   - Phase 2 (<50% HP): Enrage (+20% damage), AoE attack hits all party members for half damage\n\nAdd a `tactics` field to enemy definitions and a `selectTarget` function that uses tactics to pick targets.\n\nFiles: apps/network/src/games/rpg-engine.ts, apps/network/src/games/rpg-engine.test.ts\n\nAcceptance: Goblins target squishy characters. Orcs power attack. Boss has 2 phases. Tests verify target selection and phase transitions.",
      "priority": 63,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlg5rnzm",
      "title": "Phase 4b-4: Game Angry difficulty curve â€” easyâ†’mediumâ†’hardâ†’deadlyâ†’boss",
      "description": "Apply Game Angry's encounter design pacing to dungeon generation in rpg-engine.ts:\n\n1. Add a `difficulty` field to each room: 'easy' | 'medium' | 'hard' | 'deadly' | 'boss'\n2. Rooms 1-3: easy (enemies at 60% stats, rest rooms between combats)\n3. Rooms 4-6: medium (enemies at 80% stats, fewer rest rooms)\n4. Rooms 7-9: hard (enemies at 100% stats, at least one near-death expected)\n5. Rooms 10-11: deadly (enemies at 120% stats, traps + combat combos)\n6. Room 12: boss (multi-phase boss, callbacks to earlier rooms in description)\n\nApply difficulty multipliers during generateDungeon() based on room index. Strategic rest placement: always after a hard+ combat, never before the boss.\n\nFiles: apps/network/src/games/rpg-engine.ts, apps/network/src/games/rpg-engine.test.ts\n\nAcceptance: Each room has a difficulty field. Enemy stats scale by room position. Rest rooms placed after hard combats. Test that room 1 enemies are weaker than room 10 enemies.",
      "priority": 64,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlguvihc",
      "title": "Persistent characters: PersistentCharacter type + agent DO storage + load/save endpoints",
      "description": "Add PersistentCharacter type to packages/core/src/types.ts with fields: name, klass, level, xp, maxHp, maxMp, skills (Record<string,number>), backstory, motivation, appearance, personalityTraits (string[]), adventureLog (string[], capped at 10), achievements (string[]), inventory (string[]), createdAt, updatedAt, gamesPlayed, deaths.\n\nIn apps/network/src/agent.ts:\n- Add 'character' case to the fetch router (same pattern as 'profile' case)\n- GET /agents/:name/character â†’ this.ctx.storage.get('rpg:character')\n- PUT /agents/:name/character â†’ this.ctx.storage.put('rpg:character', body)\n- Add handleCharacter(request) method\n\nIn apps/network/src/games/rpg-engine.ts add two exported helper functions:\n- persistentToGameCharacter(pc, agent): converts PersistentCharacter to in-game Character. Resets HP/MP to maxHp/maxMp (fresh adventure). Copies name, klass, skills. Sets agent field.\n- gameCharacterToPersistent(gc, existing, adventureSummary?): Updates or creates PersistentCharacter from game Character. Increments gamesPlayed. Increments deaths if gc.hp <= 0. Appends adventureSummary to adventureLog (cap at 10 entries via slice(-9)). Updates skills from gc. Sets updatedAt.\n\nAdd tests in rpg-engine.test.ts:\n- persistentToGameCharacter resets HP/MP to max\n- gameCharacterToPersistent increments gamesPlayed\n- gameCharacterToPersistent increments deaths when hp <= 0\n- gameCharacterToPersistent caps adventureLog at 10\n\nAdd test in agent-do.test.ts:\n- GET /character returns {} when no character exists\n- PUT then GET roundtrips character data",
      "priority": 70,
      "passes": true,
      "validationCommand": "cd apps/network && pnpm vitest run",
      "acceptanceCriteria": [
        "PersistentCharacter type exists in packages/core/src/types.ts",
        "GET/PUT /agents/:name/character endpoints work",
        "persistentToGameCharacter resets HP/MP to max",
        "gameCharacterToPersistent increments gamesPlayed and deaths correctly",
        "adventureLog capped at 10 entries",
        "All existing tests pass",
        "New tests for persistence helpers and endpoints"
      ]
    },
    {
      "id": "story-mlguvug2",
      "title": "Wire character persistence into RPG environment â€” load on join, save on completion",
      "description": "Extend EnvironmentContext in apps/network/src/environments/types.ts with optional character persistence callbacks:\n  loadCharacter?: () => Promise<unknown>\n  saveCharacter?: (character: unknown) => Promise<void>\n\nIn apps/network/src/agent.ts, where environment contexts are constructed (search for EnvironmentContext or where agentName/agentDid/db are assembled), add:\n  loadCharacter: async () => this.ctx.storage.get('rpg:character'),\n  saveCharacter: async (c: unknown) => { await this.ctx.storage.put('rpg:character', c) },\n\nIn apps/network/src/environments/rpg.ts:\n1. In join_game command: before calling createCharacter, check if ctx.loadCharacter exists. If so, load persistent character. If found, use persistentToGameCharacter() to create the in-game character instead of generating fresh. Import helpers from rpg-engine.\n2. In game completion (search for 'game.completed' log or phase='finished'): if ctx.saveCharacter exists, call gameCharacterToPersistent() for each party member's agent and save via their context. Note: we only have the current agent's context, so save only the current agent's character.\n3. In buildContext: if persistent character has backstory, add \"Your backstory: {backstory}\" to context lines. If adventureLog has entries, add \"Previous adventures: {last 3 entries}\" to context.\n\nAdd tests in rpg.test.ts:\n- When loadCharacter returns a PersistentCharacter, join_game uses that character's name/class/stats\n- When loadCharacter returns null, join_game creates fresh character as before\n- buildContext includes backstory when persistent character has one",
      "priority": 71,
      "passes": true,
      "validationCommand": "cd apps/network && pnpm vitest run",
      "acceptanceCriteria": [
        "EnvironmentContext has loadCharacter and saveCharacter optional fields",
        "join_game loads persistent character when available",
        "join_game falls back to fresh character when no persistent character",
        "Game completion saves updated character back to DO",
        "buildContext includes backstory and adventure log from persistent character",
        "All existing tests pass"
      ]
    },
    {
      "id": "story-mlguwbeo",
      "title": "Character backstory conversation â€” setup phase with DM-player dialogue",
      "description": "Add a setup phase to RPG games where the DM has a back-and-forth with each player to develop their character backstory. Only triggers for characters without an existing backstory (new characters).\n\nIn apps/network/src/games/rpg-engine.ts, add to RpgGameState:\n  setupPhase?: {\n    currentPlayerIndex: number\n    exchangeCount: number\n    maxExchanges: number  // default 2\n    dialogues: Record<string, string[]>  // agent -> array of dialogue messages\n    complete: boolean\n  }\n\nAdd new RPG commands in apps/network/src/environments/rpg.ts:\n- setup_respond: Player responds to DM backstory question. Params: { gameId, message }. Appends message to dialogues[agent], increments exchangeCount. If exchangeCount >= maxExchanges, move to next player (currentPlayerIndex++). If all players done, set setupPhase.complete = true.\n- setup_narrate: DM asks a question or narrates. Params: { gameId, message, target? }. Appends to dialogues. Only grimlock can use this.\n- setup_finalize: DM wraps up setup. Params: { gameId, backstories: Record<string, string> }. Writes backstory string to each Character in party. Sets setupPhase.complete, transitions game to active exploration (remove setupPhase, start at room 0).\n\nIn buildContext during setup phase:\n- If setupPhase exists and !complete:\n  - For DM (grimlock): \"SETUP PHASE: You are interviewing {currentPlayer} about their character. Ask about their origin, motivation, and appearance. Keep it brief (2-3 exchanges per player). Use setup_narrate to ask questions, then setup_finalize when all players have backstories.\"\n  - For current player: \"The DM is asking about your character's backstory. Respond in character using setup_respond. Be creative â€” this defines who you are.\"\n  - For other players: \"Waiting for {currentPlayer} to finish backstory with DM.\"\n\nIn getAutoPlayActions during setup phase:\n  - If DM's turn and no dialogue yet for current player: auto-inject setup_narrate asking \"Tell me about your character...\"\n  - If player's turn: auto-inject setup_respond with a creative response based on their class\n\nOn new_game: if any player lacks a persistent backstory, initialize setupPhase with currentPlayerIndex=0, maxExchanges=2.\n\nAdd isActionTaken check for setup_respond, setup_narrate, setup_finalize.\n\nTests:\n- Setup phase initializes on new game\n- setup_respond advances exchange count\n- setup_finalize writes backstories and completes setup\n- buildContext shows correct prompts per role during setup",
      "priority": 72,
      "passes": true,
      "validationCommand": "cd apps/network && pnpm vitest run",
      "acceptanceCriteria": [
        "New game initializes setupPhase when characters lack backstory",
        "setup_respond command works for players",
        "setup_narrate command works for DM only",
        "setup_finalize writes backstories to characters and transitions to active",
        "buildContext shows setup-specific prompts",
        "Auto-play works during setup phase",
        "All existing tests pass"
      ]
    },
    {
      "id": "story-mlguwnws",
      "title": "XP and leveling system â€” encounter rewards + stat growth on level up",
      "description": "Add XP rewards for encounters and a leveling system.\n\nIn apps/network/src/games/rpg-engine.ts:\n\nAdd XP constants:\n  const XP_PER_ENEMY_KILL = 25\n  const XP_PER_ROOM_CLEAR = 50\n  const XP_PER_BOSS_KILL = 100\n  const XP_PER_ADVENTURE_COMPLETE = 200\n  const XP_TABLE = [0, 100, 300, 600, 1000, 1500, 2100, 2800, 3600, 4500] // XP needed for levels 1-10\n\nAdd exported function:\n  export function awardXp(pc: PersistentCharacter, amount: number): { leveledUp: boolean; newLevel: number } \n  - Adds amount to pc.xp\n  - Checks XP_TABLE to see if level should increase\n  - If leveled up: increment pc.level, increase pc.maxHp by 5+level, increase pc.maxMp by 3+level, add random skill point (+5 to a random skill)\n  - Returns whether they leveled up and new level\n\nIn apps/network/src/environments/rpg.ts:\n- After enemy killed in combat: track XP earned in game log\n- On room clear (explore advances room): award XP_PER_ROOM_CLEAR to all living party members\n- On boss kill: award XP_PER_BOSS_KILL\n- On adventure complete (game.completed): award XP_PER_ADVENTURE_COMPLETE\n- When saving persistent character on game end, apply accumulated XP via awardXp()\n\nIn buildContext: show character level and XP progress (\"Level 3 Warrior (450/600 XP to next level)\")\n\nTests:\n- awardXp correctly levels up character\n- awardXp increases stats on level up\n- XP_TABLE progression is correct\n- Multiple level ups from large XP award work correctly",
      "priority": 73,
      "passes": true,
      "validationCommand": "cd apps/network && pnpm vitest run",
      "acceptanceCriteria": [
        "XP awarded for enemy kills, room clears, boss kills, adventure completion",
        "awardXp function correctly handles leveling",
        "Stats increase on level up (HP, MP, random skill)",
        "Level shown in buildContext",
        "All existing tests pass"
      ]
    },
    {
      "id": "story-mlgux0y8",
      "title": "Campaign memory â€” adventure log compaction + previously-on context injection",
      "description": "When a game ends, the DM compacts the adventure into a narrative summary stored on each character. Future games inject this as campaign context.\n\nIn apps/network/src/environments/rpg.ts:\n\nOn game completion (where game.completed is logged), generate an adventure summary from the game log:\n  export function compactAdventureLog(game: RpgGameState): string\n  - Takes the game's log entries and generates a 2-3 sentence summary\n  - Format: \"The party of {names} ventured into {theme} dungeon. {key events from log - kills, deaths, room clears}. {outcome: victory/TPK/abandoned}.\"\n  - Include notable moments: boss kills, player deaths, barrier breaks\n  - Cap at 200 characters\n\nThis summary is passed to gameCharacterToPersistent() as the adventureSummary parameter (already implemented in story 70).\n\nIn buildContext, when persistent character has adventureLog entries:\n  Add to context lines:\n  \"ðŸ“œ CAMPAIGN HISTORY:\"\n  \"Your previous adventures:\"\n  - For each entry in adventureLog (last 3): \"- {entry}\"\n  This goes AFTER the character intro but BEFORE the tactical skills.\n\nAlso add to buildContext when persistent character has achievements:\n  \"ðŸ† Your achievements: {achievements.join(', ')}\"\n\nOn notable events during gameplay, add achievements to persistent character:\n- First boss kill â†’ \"Dragonslayer\" (or based on enemy type)\n- Survived with <10% HP â†’ \"Death's Doorstep\"\n- Cleared dungeon without taking damage â†’ \"Untouchable\"\n- 5+ games played â†’ \"Veteran Adventurer\"\n\nTests:\n- compactAdventureLog generates summary from game state\n- compactAdventureLog caps at 200 chars\n- buildContext includes campaign history when adventureLog exists\n- buildContext includes achievements when present\n- Achievement triggers fire correctly",
      "priority": 74,
      "passes": true,
      "validationCommand": "cd apps/network && pnpm vitest run",
      "acceptanceCriteria": [
        "compactAdventureLog generates narrative summary from game state",
        "Summary capped at 200 characters",
        "buildContext injects campaign history",
        "buildContext shows achievements",
        "Achievements awarded on notable events",
        "All existing tests pass"
      ]
    },
    {
      "id": "story-mlguxbgw",
      "title": "anet CLI: add character and campaign commands",
      "description": "Update ~/.local/bin/anet CLI with new commands for the campaign system.\n\nAdd these cases to the case statement:\n\n  char|c)\n    # View agent's persistent character\n    agent=\"${1:?usage: anet char <agent>}\"\n    curl -sf -H \"$AUTH\" \"$API/agents/$agent/character\" | jq .\n    ;;\n\n  party)\n    # Show all agents' characters side by side\n    for agent in slag snarl swoop; do\n      echo \"=== $agent ===\"\n      curl -sf -H \"$AUTH\" \"$API/agents/$agent/character\" | jq '{name, klass, level, xp, gamesPlayed, deaths, backstory: (.backstory // \"none\")[:80], achievements}'\n    done\n    ;;\n\n  campaign)\n    # Show campaign state â€” all characters + last adventures\n    for agent in slag snarl swoop; do\n      curl -sf -H \"$AUTH\" \"$API/agents/$agent/character\" | jq '{\n        agent: \"'$agent'\",\n        character: .name,\n        class: .klass,\n        level: .level,\n        xp: .xp,\n        games: .gamesPlayed,\n        deaths: .deaths,\n        lastAdventure: (.adventureLog[-1:][0] // \"none\"),\n        achievements: (.achievements | length)\n      }'\n    done\n    ;;\n\nUpdate help text to include:\n  char, c <agent>        View agent's persistent character\n  party                  Show all party characters\n  campaign               Campaign overview (all characters + history)\n\nThis is a bash script at ~/.local/bin/anet. Make the edits directly.",
      "priority": 75,
      "passes": true,
      "validationCommand": "bash -n ~/.local/bin/anet && echo PASS",
      "acceptanceCriteria": [
        "anet char <agent> shows character data",
        "anet party shows all characters",
        "anet campaign shows campaign overview",
        "Help text updated",
        "Script passes bash -n syntax check"
      ]
    },
    {
      "id": "story-mlgxf8wb",
      "title": "Agent @mention messaging on feed â€” in-character dialogue + OOC table talk",
      "description": "Add a `send_message` tool so agents can communicate with each other on the game feed using @mentions.\n\n## Design\n- New tool: `send_message` with params `{to: string, message: string, type: 'ic'|'ooc'}`\n- `to` uses agent names with @ prefix: `@slag`, `@snarl`, `@swoop`, `@party` (broadcast), `@dm`\n- `type: 'ic'` = in-character dialogue (uses fantasy character names in speech, @agent for routing)\n- `type: 'ooc'` = out-of-character table talk / meta / strategy discussion\n- Messages appear on the game feed as a new entry type\n- On an agent's turn, recent messages mentioning them are included in their context\n- No forced responses â€” agents see messages and respond if they choose to\n- Rate limit: max 2 messages per agent per round (prevent spam loops)\n\n## Implementation\n- Add `send_message` to RPG environment's tool list in rpg.ts\n- Add `FeedMessage` type to rpg-engine.ts: `{sender: string, to: string, message: string, type: 'ic'|'ooc', timestamp: number}`\n- Add `feedMessages: FeedMessage[]` to RpgGameState (rolling buffer, last 20)\n- In execute(): handle send_message command â€” validate to/type, push to feedMessages, trim to 20\n- In buildContext(): include recent messages mentioning this agent\n- Add to isActionTaken() â€” sending a message counts as taking action\n- Tests: send_message adds to feed, context includes mentions, rate limit works\n\n## Files\n- `apps/network/src/environments/rpg.ts` â€” new tool + feed message handling\n- `apps/network/src/games/rpg-engine.ts` â€” FeedMessage type on RpgGameState\n- `apps/network/src/environments/rpg.test.ts` â€” tests",
      "priority": 1,
      "passes": true
    },
    {
      "id": "story-mlh8s8df",
      "title": "Diverse monster bestiary â€” populate buildCombatRoom and buildBossRoom with themed enemies",
      "description": "Replace the hardcoded goblin/orc/boss in `buildCombatRoom` and `buildBossRoom` (rpg-engine.ts ~527-570) with a theme-aware bestiary. The Enemy type already has `morale?: number`, `negotiable?: boolean`, `flavorText?: string` fields and expanded `EnemyTacticKind` (pack, ambush, ranged, spellcaster, berserker, retreater, swarm, guardian).\n\n**Create a `BESTIARY` constant** â€” a record keyed by DungeonTheme, each containing arrays of enemy templates per tier:\n\n```ts\nconst BESTIARY: Record<DungeonTheme, { early: EnemyTemplate[], mid: EnemyTemplate[], boss: EnemyTemplate[] }> = {\n  'Forgotten Crypt': {\n    early: [\n      { name: 'Skeleton', hp: [5,8], DEX: 35, attack: 30, dodge: 20, morale: 12, negotiable: false, tactics: { kind: 'skeleton' }, flavorText: 'Bones clatter as it rises.' },\n      { name: 'Zombie', hp: [8,12], DEX: 20, attack: 35, dodge: 10, morale: 12, negotiable: false, tactics: { kind: 'berserker' }, flavorText: 'It shambles forward, relentless.' },\n    ],\n    mid: [\n      { name: 'Wraith', hp: [12,16], DEX: 50, attack: 45, dodge: 35, morale: 10, negotiable: false, tactics: { kind: 'ambush' }, flavorText: 'A cold presence seeps from the walls.' },\n      { name: 'Ghoul', hp: [10,14], DEX: 40, attack: 40, dodge: 25, morale: 8, negotiable: false, tactics: { kind: 'pack' }, flavorText: 'It hungers for living flesh.' },\n    ],\n    boss: [\n      { name: 'Lich Lord', hp: [40,55], DEX: 55, attack: 55, dodge: 40, morale: 11, negotiable: true, tactics: { kind: 'boss', specialEveryTurns: 2 }, flavorText: 'Ancient power crackles from hollow eye sockets.' },\n    ],\n  },\n  // ... similar for all other themes\n}\n```\n\n**Themes to populate** (from existing `pickDungeonTheme`): Forgotten Crypt, Volcanic Caverns, Fungal Depths, Sunken Ruins, Glacial Fortress, Fey Hollow, plus a 'default' fallback.\n\n**Minimum 3 enemy types per tier per theme** (early, mid). Boss tier needs 1-2 options.\n\n**Update `buildCombatRoom`:**\n- Pick from `BESTIARY[theme][tier]` instead of hardcoded goblin/orc\n- Randomize which template via dice roll\n- Support mixed groups (e.g., 2 skeletons + 1 ghoul)\n- Use `hp` range: `hp[0] + rollDie(dice, hp[1] - hp[0])`\n\n**Update `buildBossRoom`:**\n- Pick from `BESTIARY[theme].boss`\n- Minions come from same theme's mid tier\n\n**DO NOT write new tests** â€” existing tests verify dungeon generation works. New acceptance tests will come in a follow-up story.\n\n**Files:** `apps/network/src/games/rpg-engine.ts` ONLY\n**Validation:** `bun run typecheck && bun run test`",
      "priority": 80,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run typecheck && bun run test",
      "acceptanceCriteria": [
        "buildCombatRoom generates at least 8 distinct enemy types (not just goblin/orc)",
        "Enemy types have morale and negotiable fields",
        "Boss room enemies match dungeon theme",
        "All existing tests still pass",
        "New tests verify monster variety and stat ranges"
      ]
    },
    {
      "id": "story-mlh8s90w",
      "title": "Non-combat encounter resolution â€” negotiate, flee, sneak, intimidate commands",
      "description": "Add 4 new RPG commands that give players alternatives to \"attack\" during combat encounters. From Phandelver: \"noncombat or another nondeadly resolution is an equally valid way to resolve many enemy encounters.\"\n\n**New commands in rpg.ts (add after the `attack` handler ~line 1220):**\n\n1. **`negotiate`** â€” Attempt to parley with enemies\n   - Only works if ALL remaining enemies have `negotiable: true`\n   - CHA-based check (roll d100 vs 40 + party_avg_level*5)\n   - Success: enemies stand down, party gets partial XP (50%), may get info/items\n   - Failure: enemies get a free attack round (penalty for failed diplomacy)\n   - Some enemies (undead, constructs, mindless beasts) CANNOT be negotiated with\n\n2. **`flee`** â€” Party attempts to run from combat\n   - DEX-based check (roll d100 vs 50)\n   - Success: party escapes, loses NO HP, but gets 0 XP and room stays dangerous\n   - Failure: each enemy gets a free attack, THEN party escapes (retreat under fire)\n   - Cannot flee from boss rooms\n\n3. **`sneak`** â€” Attempt to bypass encounter stealthily (only from explore, before combat triggers)\n   - Modify `explore` command: when entering a combat room, if player calls `sneak` instead of engaging, roll DEX check\n   - Success: skip the room entirely (0 XP, but no damage)\n   - Failure: combat starts with enemies getting surprise round (free attacks)\n   - Scout class gets +20 bonus\n\n4. **`intimidate`** â€” Frighten weaker enemies into fleeing\n   - Works on enemies with morale <= 8 AND current HP < 50%\n   - STR/CHA check (roll d100 vs 45)\n   - Success: affected enemies flee (counted as killed for XP purposes, reduced by 25%)\n   - Failure: enemies become enraged (+10 attack for rest of combat)\n\n**rpg.ts tool schema changes (~line 580-630):**\n- Add negotiate, flee, sneak, intimidate to command enum\n- Add to `isActionTaken` list (~line 1662)\n\n**buildContext changes (~line 1631):**\n- During combat, show ALL available actions, not just \"attack\":\n  `âš”ï¸ COMBAT! Enemies: ... | Actions: attack, negotiate, flee, intimidate`\n- Show which enemies are negotiable\n- Show enemy morale state (shaken, steady, fearless)\n\n**Files:** `apps/network/src/environments/rpg.ts`, `apps/network/src/games/rpg-engine.ts` (add helper functions)\n**Tests:** Add tests for each new command in rpg.test.ts â€” success/fail paths, class bonuses, XP awards\n**Validation:** `bun run check-types && bun run test`",
      "priority": 81,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run typecheck && bun run test",
      "acceptanceCriteria": [
        "negotiate command works on negotiable enemies, fails on undead/constructs",
        "flee command allows escape with DEX check, cannot flee bosses",
        "intimidate works on low-morale wounded enemies",
        "buildContext shows all available actions during combat, not just attack",
        "Each command awards appropriate XP (partial or none)",
        "All existing tests pass",
        "New tests cover success and failure paths for each command"
      ],
      "targetFiles": [
        "rpg.ts",
        "rpg-engine.ts"
      ],
      "noTestWrites": true,
      "acceptanceAssertions": [
        "negotiate",
        "flee",
        "sneak",
        "intimidate"
      ]
    },
    {
      "id": "story-mlh8s9mk",
      "title": "Fix stuck detector â€” no free combat resolution, hint system instead",
      "description": "The `gmInterveneIfStuck` function (rpg-engine.ts ~982-1030) currently auto-resolves combat by killing all enemies at 10% HP cost. This makes combat trivially easy â€” agents learn to just `explore` during combat and get free kills.\n\n**Changes to gmInterveneIfStuck:**\n\n1. **During combat mode, do NOT auto-kill enemies.** Instead:\n   - First stuck trigger (repeat 3x): Add hint to game log: \"GM whispers: Try different tactics â€” attack, negotiate, flee, or intimidate\"\n   - Second stuck trigger (repeat 5x): Add stronger hint with specific suggestion based on enemy state\n   - Third stuck trigger (repeat 7x): THEN auto-resolve, but at 30% HP cost (not 10%), and log it as \"GM deus ex machina â€” the ceiling caves in\"\n\n2. **Increase the HP cost for auto-resolve from 10% to 30%** â€” make it actually hurt\n\n3. **Change explore during combat behavior:**\n   - Currently: `explore` during combat triggers stuck detector â†’ free combat win\n   - New: `explore` during combat returns error message: \"You're in combat! Use: attack, negotiate, flee, or intimidate. Type 'status' for details.\"\n   - Do NOT count explore-during-combat toward stuck detection\n\n4. **Add `STUCK_COMBAT_THRESHOLD` constant** (default 7) separate from general `STUCK_REPEAT_THRESHOLD`\n\n**Files:** `apps/network/src/games/rpg-engine.ts`, `apps/network/src/environments/rpg.ts` (explore handler)\n**Tests:** Update stuck detection tests, add test for explore-during-combat rejection, verify graduated hint system\n**Validation:** `bun run check-types && bun run test`",
      "priority": 82,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run typecheck && bun run test",
      "acceptanceCriteria": [
        "explore during combat returns error, does not trigger stuck detection",
        "First stuck trigger in combat gives hint, not auto-resolve",
        "Auto-resolve only happens after 7 repeats, at 30% HP cost",
        "Non-combat stuck detection unchanged",
        "All existing tests pass",
        "New test verifies graduated hint system"
      ],
      "targetFiles": [
        "rpg-engine.ts"
      ],
      "noTestWrites": true,
      "acceptanceAssertions": [
        "gmInterveneIfStuck"
      ]
    },
    {
      "id": "story-mli3k0ny",
      "title": "Permadeath + Resurrection system â€” BRP-style death is permanent",
      "description": "Currently death has no consequences â€” the PersistentCharacter survives intact, just incrementing a `deaths` counter. Implement real permadeath with an optional resurrection mechanic.\n\n**BRP Death Rules (from pdf-brain):**\n- 0 HP = dead. No death saves, no coming back easily.\n- \"Let the dice fall where they may\" â€” death makes the game meaningful.\n\n**Implementation:**\n\n1. **PersistentCharacter changes:**\n   - Add `dead: boolean` field to PersistentCharacter interface in `packages/core/src/types.ts`\n   - Add `diedAt?: number` timestamp\n   - Add `causeOfDeath?: string` (e.g. \"slain by Cave Troll in Ashen Reliquary\")\n\n2. **On character death (in `gameCharacterToPersistent`):**\n   - When `gc.hp <= 0`, set `dead = true`, record `diedAt` and `causeOfDeath`\n   - Clear inventory (loot is lost with the body)\n   - Keep adventureLog and achievements (legacy lives on)\n\n3. **On game join (in `persistentToGameCharacter` and RPG env join logic):**\n   - If `persistent.dead === true`, DO NOT load the old character\n   - Instead, create a brand new Level 1 character with `createCharacter()`\n   - Log: \"Your previous character [name] fell in battle. A new hero rises.\"\n   - Reset the persistent storage with the new character\n\n4. **Resurrection mechanic (Healer class only):**\n   - Add `resurrect` command to RPG tool (only usable in combat/exploring mode)\n   - Requires: Healer class, 4+ MP cost, target must have died THIS adventure (not previous games)\n   - Skill check: `cast_spell` at -20 penalty (difficult)\n   - On success: target revives at 1 HP, loses 50% of their XP earned this adventure\n   - On failure: MP is spent, target stays dead, no retry this adventure\n   - Cannot resurrect yourself (you're dead)\n   - BRP-inspired: \"returning from the dead is quite exhausting\" â€” revived character has -10 to all skills for rest of adventure\n\n5. **Death narrative:**\n   - Record a narrative beat of kind 'death' when a character dies\n   - Log the death prominently: \"[Character] has fallen! Their adventure ends here.\"\n   - If Healer is alive, hint: \"A resurrection may yet be possible...\"\n\n6. **Existing `deaths` counter:** Keep it, but now it means \"number of permanent deaths / rerolls\"\n\n**Files to modify:**\n- `packages/core/src/types.ts` â€” PersistentCharacter interface\n- `apps/network/src/games/rpg-engine.ts` â€” persistentToGameCharacter, gameCharacterToPersistent, add resurrect spell logic\n- `apps/network/src/environments/rpg.ts` â€” join logic (detect dead char, reroll), resurrect command handler, death handling in combat\n\n**Test approach:**\n- Test that dead character creates new Level 1 on next join\n- Test resurrection success/failure paths\n- Test that inventory is cleared on death\n- Test XP penalty on resurrection\n- Test skill debuff on resurrected characters",
      "priority": 83,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -5",
      "targetFiles": [
        "packages/core/src/types.ts",
        "apps/network/src/games/rpg-engine.ts",
        "apps/network/src/environments/rpg.ts"
      ]
    },
    {
      "id": "story-mli3k7wh",
      "title": "Fix debug endpoint â€” surface rpg:character in /agents/{name}/debug",
      "description": "The `/agents/{name}/debug` endpoint returns `rpgCharacter: null` even though `/agents/{name}/character` returns the full persistent character. The debug endpoint needs to actually read `rpg:character` from DO storage.\n\n**Fix:** In `apps/network/src/agent.ts`, find the debug handler and ensure it reads `await this.ctx.storage.get('rpg:character')` and includes it in the response.\n\n**Files:** `apps/network/src/agent.ts`",
      "priority": 84,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -5",
      "targetFiles": [
        "apps/network/src/agent.ts"
      ]
    },
    {
      "id": "story-mli3kg7t",
      "title": "Sync xpEarned to in-game Character during play",
      "description": "Currently `game.xpEarned` accumulates XP per agent, but in-game `Character.xp` and `Character.level` stay at their initial values during play. Agents see \"Level 1, 0 XP\" the entire game even while earning thousands of XP.\n\n**Fix:** After every XP award (in `addXpEarned`), also update the corresponding party member's `Character.xp` and check for level-up using `XP_TABLE`. When a character levels up mid-dungeon, apply the stat growth (maxHp, maxMp, skill boost) and log it prominently.\n\nThis gives agents real-time feedback: \"Kaelen the Bold reaches Level 2! (+7 HP, +5 MP)\"\n\n**Files:**\n- `apps/network/src/environments/rpg.ts` â€” modify `addXpEarned` to sync to Character, add mid-game level-up logic\n- `apps/network/src/games/rpg-engine.ts` â€” may need to export level-up helper for in-game use",
      "priority": 85,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -5",
      "targetFiles": [
        "apps/network/src/environments/rpg.ts"
      ]
    },
    {
      "id": "story-mli3kxn1",
      "title": "Loot table system â€” tiered treasure generation with stat-affecting items",
      "description": "Currently treasure rooms give flavor text only (\"soot-black opal\") with no mechanical effect and nothing added to inventory. Implement a real loot system inspired by OSE treasure tables.\n\n**Implementation:**\n\n1. **Item types and effects** (in `rpg-engine.ts`):\n   ```\n   type ItemRarity = 'common' | 'uncommon' | 'rare' | 'legendary'\n   type ItemSlot = 'weapon' | 'armor' | 'consumable' | 'trinket'\n   type LootItem = {\n     name: string\n     rarity: ItemRarity\n     slot: ItemSlot\n     effects: { stat: string; bonus: number }[]  // e.g. [{stat: 'attack', bonus: 5}]\n     consumable?: { type: 'heal' | 'mp' | 'buff'; amount: number }\n     gold?: number  // gold value\n     description: string\n   }\n   ```\n\n2. **Loot tables by tier:**\n   - **Early rooms**: Common items â€” minor potions (heal 1d6), copper coins (5-20 gold), rusty weapons (+2 attack)\n   - **Mid rooms**: Uncommon items â€” healing potions (heal 2d6+3), silver (+5 attack/dodge), gems (20-50 gold)\n   - **Boss rooms**: Rare/legendary â€” magic weapons (+10 attack), enchanted armor (+5 armor), scrolls (one-time spell), large gold haul (50-200)\n\n3. **Treasure room resolution** (modify `explore` in rpg.ts):\n   - Roll on loot table based on room position in dungeon (early/mid/late)\n   - Add items to the acting character's inventory (or party shared â€” current player picks up)\n   - Log: \"Found: Silvered Shortsword (+5 attack) and 30 gold pieces\"\n\n4. **Combat drops** â€” small chance (20%) enemies drop loot on kill:\n   - Early enemies: copper (1-5 gold), occasional potion\n   - Mid enemies: silver (5-15 gold), uncommon items\n   - Boss: guaranteed rare+ drop\n\n5. **Gold as a resource** â€” track `gold` on Character (add to Character type):\n   - Earned from treasure rooms and enemy drops\n   - Spendable at rest rooms: buy healing potions, identify items\n\n6. **Consumable usage** â€” add `use_item` command:\n   - `use_item potion` â€” use a healing potion from inventory\n   - Items consumed on use, removed from inventory\n\n7. **Inventory persistence** â€” items carry to PersistentCharacter at game end (for living characters). Dead characters lose all items (ties into permadeath story).\n\n**Files:**\n- `apps/network/src/games/rpg-engine.ts` â€” LootItem type, loot tables, generateLoot function, Character.gold field\n- `apps/network/src/environments/rpg.ts` â€” treasure room loot generation, combat drops, use_item command, rest room shop\n- `packages/core/src/types.ts` â€” PersistentCharacter inventory type update (string[] â†’ LootItem[])",
      "priority": 86,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -5",
      "targetFiles": [
        "apps/network/src/games/rpg-engine.ts",
        "apps/network/src/environments/rpg.ts",
        "packages/core/src/types.ts"
      ]
    },
    {
      "id": "story-mli3l69p",
      "title": "Milestone XP bonuses â€” reward non-combat encounters",
      "description": "Add XP rewards for non-combat activities to incentivize diverse play:\n\n- **Trap disarmed**: 25 XP to the disarmer (Scout)\n- **Barrier cleared**: 25 XP to the class that clears it (or 15 XP to brute-forcer)\n- **Puzzle solved**: 30 XP to party\n- **Successful negotiation**: 75% of combat XP value (incentivize diplomacy)\n- **Successful intimidation**: 50% of combat XP value\n- **Successful flee**: 10 XP consolation (you survived)\n- **Rest room used**: 0 XP (no reward for resting)\n- **Treasure found**: 10 XP per item found\n\nAdd constants `XP_PER_TRAP_DISARM`, `XP_PER_BARRIER_CLEAR`, `XP_PER_PUZZLE`, `XP_PER_TREASURE_FIND` to rpg-engine.ts. Wire them into the corresponding room/action handlers in rpg.ts.\n\n**Files:**\n- `apps/network/src/games/rpg-engine.ts` â€” new XP constants\n- `apps/network/src/environments/rpg.ts` â€” wire XP awards into trap, barrier, puzzle, negotiate handlers",
      "priority": 87,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -5",
      "targetFiles": [
        "apps/network/src/games/rpg-engine.ts",
        "apps/network/src/environments/rpg.ts"
      ]
    },
    {
      "id": "story-mli4cnxe",
      "title": "Rename games â†’ environments throughout D1, API, and codebase",
      "description": "The D1 `games` table, `/games` API routes, and related code use \"games\" terminology, but the real abstraction is \"environments.\" RPG is an env. Ralph is an env. Observe is an env. Not all envs are games.\n\n**D1 migration:**\n- Rename `games` table â†’ `environments` (or create new table + migrate data + drop old)\n- Columns stay the same: id, type, phase, host_agent, players, winner, state, created_at, updated_at\n\n**API routes:**\n- `GET /games` â†’ `GET /environments` (keep `/games` as alias for backwards compat temporarily)\n- `GET /games/:id` â†’ `GET /environments/:id`\n- `DELETE /games/:id` â†’ `DELETE /environments/:id`\n- `POST /games` â†’ `POST /environments`\n- Update all route handlers in `apps/network/src/index.ts`\n\n**Code references:**\n- Grep for `games` table references in all .ts files and update\n- Update type names: `GameRow` â†’ `EnvironmentRow` where appropriate\n- Update variable names in observe.ts, rpg.ts, catan.ts, agent.ts\n- Update D1 queries: `FROM games` â†’ `FROM environments`\n\n**CLI (anet):**\n- `anet games` â†’ `anet envs` (keep `games` as alias)\n- `anet games-all` â†’ `anet envs --all`\n\n**Backwards compat:**\n- Keep `/games` routes as aliases that redirect/proxy to `/environments` for one release cycle\n- Log deprecation warning when old routes are hit\n\n**Files:**\n- `apps/network/src/index.ts` â€” routes\n- `apps/network/src/environments/rpg.ts` â€” D1 queries\n- `apps/network/src/environments/observe.ts` â€” D1 queries  \n- `apps/network/src/agent.ts` â€” game/env references\n- D1 migration SQL",
      "priority": 91,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -5",
      "targetFiles": [
        "apps/network/src/index.ts",
        "apps/network/src/environments/rpg.ts",
        "apps/network/src/environments/observe.ts"
      ]
    },
    {
      "id": "story-mli4kg2l",
      "title": "anet v2 â€” pure agent o11y and debugging CLI",
      "description": "Rethink anet as a pure agent observability and debugging CLI. NOT a game/env CLI. It answers: Are agents healthy? What are they thinking? Where are they stuck? What went wrong?\n\n**Keep/improve:**\n- `anet health` â€” agent health (errors, loop count, uptime)\n- `anet debug <agent>` â€” full debug dump\n- `anet transcript <agent>` â€” last loop transcript\n- `anet config <agent> [json]` â€” get/patch config\n- `anet deploy` â€” deploy worker\n- `anet reset/reset-all` â€” reset DOs\n\n**New o11y commands:**\n- `anet errors` â€” aggregate errors across all agents, grouped by category, sorted by recency\n- `anet loops [agent]` â€” loop performance: avg duration, tool calls per loop, success rate\n- `anet trace <agent>` â€” last decision chain: observeâ†’thinkâ†’actâ†’reflect with timing\n- `anet slow` â€” find agents with degraded performance (>30s avg, increasing errors)\n- `anet stuck` â€” detect agents in error backoff or repeating same action\n\n**Environment views (generic):**\n- `anet envs` â€” list active environments (replaces `games`)\n- `anet env <id>` â€” dump env state (generic JSON, env provides its own debugView)\n- Environments register a `debugView()` on AgentEnvironment interface that returns structured o11y data. anet renders it without knowing RPG/Catan internals.\n\n**Remove RPG-specific commands from anet core:**\n- party, char, campaign, rpg, log â†’ not agent o11y. Can live as separate convenience scripts.\n\n**Output:**\n- `--json` flag on all commands for scripting\n- Color-coded health (green/yellow/red via tput)\n- Compact tables for multi-agent views\n\n**New API endpoints needed:**\n- `GET /admin/errors` â€” aggregated errors across agents\n- `GET /admin/loops?agent=X` â€” loop performance metrics\n- `GET /agents/:name/trace` â€” last decision chain with timing\nAdd to `apps/network/src/index.ts`\n\n**Files:**\n- `~/.local/bin/anet` â€” CLI rewrite\n- `apps/network/src/index.ts` â€” new admin endpoints\n- `apps/network/src/environments/types.ts` â€” debugView on AgentEnvironment",
      "priority": 92,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -5",
      "targetFiles": [
        "apps/network/src/index.ts",
        "apps/network/src/environments/types.ts"
      ]
    },
    {
      "id": "story-mlip8uf4",
      "title": "Campaign data layer â€” types, D1 schema, CRUD helpers",
      "description": "Create two new files. Do NOT modify any existing files.\n\nFile 1: apps/network/migrations/0002_add_campaigns.sql\nContents:\nCREATE TABLE IF NOT EXISTS campaigns (id TEXT PRIMARY KEY, name TEXT NOT NULL, premise TEXT DEFAULT '', world_state TEXT DEFAULT '{}', story_arcs TEXT DEFAULT '[]', created_at TEXT NOT NULL, updated_at TEXT NOT NULL);\n\nFile 2: apps/network/src/campaign.ts\nContents: Export TypeScript types (Faction, PlotPoint, StoryArc, WorldState, CampaignState) and three async functions (createCampaign, getCampaign, updateCampaign) that do D1 SQL operations on the campaigns table. Use crypto.randomUUID() for IDs. Store worldState and storyArcs as JSON strings in D1.",
      "priority": 93,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run check-types && bun run test",
      "targetFiles": [
        "rpg-engine.ts",
        "rpg.ts"
      ]
    },
    {
      "id": "story-mlip8v51",
      "title": "Campaign API endpoints â€” create, get, list, start adventure",
      "description": "Add HTTP routes for campaign management in apps/network/src/index.ts:\n\n1. POST /environments/rpg/campaign â€” create campaign (body: {name, premise?})\n2. GET /environments/rpg/campaign/:id â€” get campaign state\n3. GET /environments/rpg/campaigns â€” list all campaigns\n4. POST /environments/rpg/campaign/:id/start-adventure â€” create RPG env linked to campaign\n\nAll require admin auth. Use the CRUD helpers from previous story.\nAdd tests in index.test.ts.",
      "priority": 94,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run check-types && bun run test",
      "targetFiles": [
        "index.ts"
      ]
    },
    {
      "id": "story-mlip8vr6",
      "title": "Adventure threading â€” dungeon themes from campaign story arcs",
      "description": "When generating a dungeon for a campaign-linked environment, use the campaign's active story arcs to determine theme and objectives.\n\nIn rpg.ts, when starting a new RPG game that has campaign_id:\n1. Load campaign state\n2. Pick the active story arc with next unresolved plot point\n3. Pass arc name + plot point as dungeon theme context to generateDungeon/craft_dungeon\n4. After adventure completes, mark the plot point as resolved\n5. Update campaign with adventure outcome\n\nModify the GM system prompt to include \"Previously on...\" from campaign adventure log (last 2-3 adventures summarized in 1 sentence each).\n\nKeep changes focused on rpg.ts â€” the engine types are already in place from the data layer story.",
      "priority": 95,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run check-types && bun run test",
      "targetFiles": [
        "rpg.ts"
      ]
    },
    {
      "id": "story-mlip8wfo",
      "title": "Faction reputation â€” disposition tracking with gameplay consequences",
      "description": "Add faction disposition mechanics to the campaign system.\n\n1. In rpg-engine.ts add helper functions:\n   adjustDisposition(campaign, factionId, delta, reason) â†’ updated campaign\n   getDispositionTier(disposition: number) â†’ 'hostile'|'unfriendly'|'neutral'|'friendly'|'allied'\n\n2. Thresholds: hostile(<-50), unfriendly(-50 to -10), neutral(-9 to +9), friendly(+10 to +49), allied(>=50)\n\n3. In rpg.ts, after combat encounters:\n   - If enemies belong to a faction, adjust disposition on kill (-20) or negotiate (+10)\n   - Log disposition changes in campaign events\n\n4. Add get_reputation RPG tool command for agents to check faction standing\n\n5. Include faction context in GM prompt: \"The Iron Brotherhood considers you allies (+65)\"\n\nTests for disposition math and tier calculation.",
      "priority": 96,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run check-types && bun run test",
      "targetFiles": [
        "rpg-engine.ts",
        "rpg.ts"
      ]
    },
    {
      "id": "story-mlip8x1w",
      "title": "Hub town â€” downtime phase between campaign adventures",
      "description": "Add hub_town game phase between dungeon crawls in campaign mode.\n\n1. Add 'hub_town' to RPG game phases in rpg-engine.ts\n2. After adventure completion in campaign mode, transition to hub_town instead of auto-restart\n3. Hub town actions (new RPG tool commands):\n   - visit_location(location) â€” tavern, market, temple, guild_hall\n   - buy_item(itemId) â€” spend gold on equipment\n   - sell_item(itemId) â€” sell loot\n   - rest â€” full heal\n   - embark â€” leave town, start next adventure\n4. Auto-embark after 5 idle turns\n5. GM narrates hub based on campaign context\n\nKeep it simple â€” hub is a state machine with locations, not a full simulation.",
      "priority": 97,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run check-types && bun run test",
      "targetFiles": [
        "rpg-engine.ts",
        "rpg.ts"
      ]
    },
    {
      "id": "story-mlip8xov",
      "title": "Session zero â€” auto-generate campaign premise from party composition",
      "description": "When creating a campaign, auto-generate a premise based on the party's persistent characters.\n\n1. In createCampaign, accept optional theme parameter\n2. Generate premise with: 3-4 factions, starting location, central conflict, 2-3 seeded story arcs\n3. Use character classes/levels to inform world (high-level party = bigger threats)\n4. Add previously_on helper that generates narrative recap from campaign history\n5. Inject previously_on into GM prompt at adventure start\n\nGeneration is deterministic from inputs (theme + party) â€” no LLM call needed, use template tables.",
      "priority": 98,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && bun run check-types && bun run test",
      "targetFiles": [
        "rpg-engine.ts",
        "rpg.ts"
      ]
    },
    {
      "id": "story-mlit6mcg",
      "title": "plan_campaign GM tool â€” LLM-driven campaign worldbuilding",
      "description": "Add a `plan_campaign` command to the GM tool in `apps/network/src/tools/gm-tool.ts`.\n\nWhen Grimlock calls `plan_campaign` with party composition, the tool:\n1. Queries pdf-brain for campaign design patterns (Game Angry, etc.)\n2. Builds a prompt with party classes/levels/backstories\n3. Calls the LLM (via ctx.env.AI) to generate structured campaign data\n4. Returns and persists: campaign name, premise, 3-5 factions (each with name, description, disposition, key NPC), central villain with lieutenants, 2-3 allied NPCs, hub town (name, description, locations with shopkeepers/quest-givers), 3-4 story arcs with plot points, regional map of named locations\n5. Stores result in D1 via createCampaign() â€” extend the campaigns table schema if needed\n\nThe LLM prompt should reference pdf-brain results as inspiration. The output is structured JSON matching CampaignState (extend the type as needed for NPCs, hub town, villain details).\n\nAdd the command enum value, parameter schema, and handler in gm-tool.ts following the craft_dungeon pattern. Add tests.",
      "priority": 100,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run 2>&1 | tail -5"
    },
    {
      "id": "story-mlit6tsb",
      "title": "advance_campaign GM tool â€” evolve world state between adventures",
      "description": "Add an `advance_campaign` command to the GM tool in `apps/network/src/tools/gm-tool.ts`.\n\nWhen Grimlock calls `advance_campaign` after an adventure completes, the tool:\n1. Takes the adventure outcome (who survived, what happened, rooms cleared, enemies defeated, choices made)\n2. Loads the campaign state from D1\n3. Calls the LLM to decide: which factions gained/lost power, which NPCs react (new allies, betrayals, deaths), which plot points resolved or advanced, what new threats emerge, how the hub town changed\n4. Updates campaign state in D1 via updateCampaign()\n5. Returns a narrative summary of world changes\n\nThe LLM prompt includes current campaign state, adventure log, and party actions. Output is a structured patch to CampaignState.\n\nAdd command enum, params (campaignId, adventureSummary), handler following plan_campaign pattern. Add tests.",
      "priority": 101,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run 2>&1 | tail -5"
    },
    {
      "id": "story-mlit70y6",
      "title": "Fix start-adventure endpoint and wire campaign into game creation",
      "description": "Fix the 500 error on POST `/environments/rpg/campaign/:id/start-adventure`.\n\nDebug: the endpoint calls `createRpgGame({id, players, campaignState: campaign})` which crashes at runtime. Find and fix the type mismatch or missing field causing the error. The campaign object from getCampaign() has: id, name, premise, worldState, storyArcs, adventureCount.\n\nAlso ensure the created game's dungeon theme pulls from the campaign's story arcs and premise (use withCampaignTheme which already exists).\n\nAdd error logging in the catch block so future errors are visible. Add a test for the start-adventure flow.",
      "priority": 102,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run 2>&1 | tail -5"
    },
    {
      "id": "story-mlit78mz",
      "title": "Remove template mad-libs from campaign code",
      "description": "Delete the hardcoded template arrays and procedural campaign generation from `apps/network/src/games/rpg-engine.ts`:\n\nRemove these constants and all functions that use them:\n- CAMPAIGN_FACTION_TEMPLATES\n- CAMPAIGN_LOCATION_TEMPLATES  \n- CAMPAIGN_CONFLICT_TEMPLATES\n- CAMPAIGN_ARC_TEMPLATES\n- buildCampaignPremiseFromParty()\n- buildFactionSet()\n- partyMotif()\n- factionDispositionByRole()\n- replaceTemplateTokens()\n- All the seededPick campaign helpers\n\nKeep the CampaignState, CampaignPremiseTemplate, Faction, StoryArc, PlotPoint types â€” those are still used by the GM tools.\n\nKeep previously_on() â€” that's useful.\n\nUpdate any imports/callers. Update tests to remove tests for deleted functions. All remaining tests must pass.",
      "priority": 103,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run 2>&1 | tail -5"
    },
    {
      "id": "story-mliud6pe",
      "title": "Rewrite craft_dungeon to use LLM for dungeon generation",
      "description": "Rewrite the `craft_dungeon` command in `apps/network/src/tools/gm-tool.ts` to generate dungeons via LLM instead of calling `generateDungeon()`.\n\nCurrent flow: consult pdf-brain â†’ call generateDungeon() (procedural) â†’ attach library context\nNew flow: consult pdf-brain â†’ build prompt with party stats, theme, campaign context, library results â†’ call LLM via ctx.env.AI â†’ parse structured JSON output into Room[] array â†’ set on game state\n\nThe LLM prompt should include pdf-brain results as inspiration, party composition, campaign context if active, and request 10-12 rooms with varied types and a difficulty curve. Each room needs type, description, enemies (if combat/boss), requiredClass (if barrier). Output must match existing Room type. Fallback to generateDungeon() if LLM fails. Add tests mocking ctx.env.AI.",
      "priority": 104,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run 2>&1 | tail -5"
    },
    {
      "id": "story-mliuddpv",
      "title": "Remove procedural dungeon generation â€” delete generateDungeon and template arrays",
      "description": "Delete procedural dungeon generation from `apps/network/src/games/rpg-engine.ts`: DUNGEON_THEMES array, pickDungeonTheme(), generateDungeon(), buildCombatRoom(), buildBossRoom(), and all enemy/boss template arrays used only by these functions. Keep Room/Enemy/DungeonTheme types, withCampaignTheme(), and anything used elsewhere. Update createRpgGame to start with empty dungeon and mode 'setup' when no dungeon provided. Remove tests for deleted functions, ensure remaining tests pass.",
      "priority": 105,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run 2>&1 | tail -5"
    },
    {
      "id": "story-mlizbw13",
      "title": "Fix campaign start-adventure: set mode='exploring' and currentPlayer",
      "description": "In `apps/network/src/index.ts`, the `start-adventure` route creates games with `mode: 'setup'` (the createRpgGame default) but phase='playing'. This leaves a 0-dungeon game in limbo. Fix: after `game.phase = 'playing'`, also set `game.mode = 'exploring'` and set `game.currentPlayer = 'grimlock'` so the GM gets first turn to craft_dungeon. The dungeon starts empty â€” that's fine, grimlock will craft_dungeon on its first auto-play turn.",
      "priority": 110,
      "passes": true,
      "validationCommand": "cd apps/network && bun test",
      "targetFiles": [
        "index.ts"
      ]
    },
    {
      "id": "story-mlizbwr4",
      "title": "Auto-play: grimlock craft_dungeon when dungeon is empty",
      "description": "In `apps/network/src/environments/rpg.ts` in `getAutoPlayActions`, when grimlock finds an active game where it's the host and `state.dungeon.length === 0`, inject a `craft_dungeon` GM tool call instead of returning empty. Add this check after the `findActiveGameWhereItsMyTurn` logic â€” if grimlock has an active game (via findActiveGameForAgent) but dungeon is empty, return `[{ name: 'gm', arguments: { command: 'craft_dungeon', gameId: row.id } }]`. This ensures campaign adventures get their dungeon crafted automatically.",
      "priority": 111,
      "passes": false,
      "validationCommand": "cd apps/network && bun test",
      "targetFiles": [
        "rpg.ts"
      ]
    },
    {
      "id": "story-mlizbxc1",
      "title": "Grimlock auto-create uses campaign instead of standalone",
      "description": "In `apps/network/src/environments/rpg.ts` in `getAutoPlayActions`, when grimlock auto-creates because no playing environments exist, it should check for an active campaign first. Change the grimlock auto-create block: query D1 for `SELECT id FROM campaigns ORDER BY created_at DESC LIMIT 1`. If a campaign exists, use `{ command: 'new_game', players: ['slag', 'snarl', 'swoop'], campaignId: campaign.id }` instead of just `{ command: 'new_game', players: ['slag', 'snarl', 'swoop'] }`. The `new_game` handler already supports `campaignId` parameter.",
      "priority": 112,
      "passes": false,
      "validationCommand": "cd apps/network && bun test",
      "targetFiles": [
        "rpg.ts"
      ]
    },
    {
      "id": "story-mlizby0h",
      "title": "Fix embark: link new adventure to campaign in D1",
      "description": "In `apps/network/src/environments/rpg.ts` in the `embark` command handler (~line 2400), after the game state is updated in D1, call `linkAdventureToCampaign(db, gameId, campaignId)` if `campaignId` is present. Currently embark updates the game in-place but never calls linkAdventureToCampaign, so the campaign adventure count doesn't track properly. Import `linkAdventureToCampaign` from `../campaign` if not already imported.",
      "priority": 113,
      "passes": false,
      "validationCommand": "cd apps/network && bun test",
      "targetFiles": [
        "rpg.ts"
      ]
    }
  ],
  "metadata": {
    "createdAt": "2026-02-08T06:54:17.324Z",
    "totalIterations": 91,
    "lastIteration": "2026-02-12T02:43:31.120Z"
  },
  "totalStories": 11
}