{
  "version": "1.0",
  "projectName": "atproto-agent-network-pi-loop",
  "description": "Epic #50: Real Pi Agent Loop â€” DO IS the Agent. Replace AI SDK with Pi, implement persistent agent config, session trees, alarm-driven autonomous loop, Pi tools, agent creation API, dashboard enhancements, and self-extending agents.",
  "stories": [
    {
      "id": "story-mlde1mhv",
      "title": "Install Pi deps + replace AI SDK wrapper",
      "description": "**REPLACE AI SDK WITH PI â€” STEP BY STEP**\n\n1. Install Pi packages:\n   ```bash\n   pnpm add @mariozechner/pi-ai@0.52.8 --filter @atproto-agent/network\n   pnpm add @mariozechner/pi-ai@0.52.8 @mariozechner/pi-agent-core@0.52.8 --filter @atproto-agent/agent\n   ```\n\n2. Remove AI SDK packages:\n   ```bash\n   pnpm remove ai @openrouter/ai-sdk-provider --filter @atproto-agent/network\n   ```\n\n3. Read the current ai-provider.ts:\n   ```bash\n   cat apps/network/src/ai-provider.ts\n   ```\n\n4. Write new ai-provider.ts using Pi API:\n   ```typescript\n   import { getModel, complete, type Context } from '@mariozechner/pi-ai'\n   \n   export function getOpenRouterModel(modelId: string) {\n     return getModel('openrouter', modelId)\n   }\n   \n   export async function completeWithOpenRouter(\n     model: string,\n     context: Context,\n     options?: { tools?: any[] }\n   ) {\n     const model_obj = getOpenRouterModel(model)\n     return complete(model_obj, context, options)\n   }\n   ```\n\n5. Read the current agent-factory.ts:\n   ```bash\n   cat apps/network/src/agent-factory.ts\n   ```\n\n6. Rewrite agent-factory.ts to use Pi:\n   - Replace all imports from 'ai' with imports from '@mariozechner/pi-ai'\n   - Replace generateText() calls with complete() calls\n   - Keep the factory function signature the same\n   - Maintain OpenRouter + CF AI Gateway routing\n\n7. Run tests to verify:\n   ```bash\n   pnpm test 2>&1 | tail -5\n   ```\n\n8. Run typecheck:\n   ```bash\n   pnpm typecheck\n   ```\n\nSuccess criteria:\n- All 86 tests pass\n- No imports from 'ai' package remain\n- Agent factory returns working prompt() function\n- Typecheck clean",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "pnpm install succeeds with Pi packages",
        "No imports from 'ai' or '@openrouter/ai-sdk-provider' remain",
        "Agent /prompt endpoint uses Pi complete()",
        "All 86+ tests pass",
        "TypeScript compiles clean"
      ]
    },
    {
      "id": "story-mlde1tos",
      "title": "Agent config schema + DO storage",
      "description": "GitHub Issue #52. Define and persist per-agent configuration in DO storage. Create AgentConfig interface: name, personality (system prompt), specialty, model (default moonshotai/kimi-k2.5), fastModel (google/gemini-2.0-flash-001), loopIntervalMs (default 60000), goals array (AgentGoal with id/description/priority/status/progress/createdAt/completedAt), enabledTools array. Store config in DO storage under 'config' key in AgentDO (apps/network/src/agent.ts). Add GET /agents/{name}/config endpoint (returns config). Add PATCH /agents/{name}/config endpoint (partial update, merges with existing). Config is set at agent creation time and updatable at runtime. Add types to packages/core/src/types.ts or a new file. Add tests for config CRUD operations.",
      "priority": 2,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "AgentConfig interface defined with all fields",
        "Config persists in DO storage across requests",
        "GET /agents/{name}/config returns stored config",
        "PATCH /agents/{name}/config merges updates",
        "Tests for config storage and retrieval"
      ]
    },
    {
      "id": "story-mlde2057",
      "title": "Pi session persistence in DO storage",
      "description": "GitHub Issue #53. Persist Pi session context (messages array) in DO storage so agents maintain conversation history across alarms and DO evictions. In AgentDO (apps/network/src/agent.ts): save Pi Context messages to DO storage after each interaction under 'session' key. Load session on DO initialize(). Implement window management: keep last 50 messages in DO storage, archive overflow to D1 (agent-records). Add helper methods: loadSession(), saveSession(), trimSession(). The session should include role, content, timestamp, and any tool call results. Support Pi session branching concept (store branch points). Add tests for session save/load/trim/branch.",
      "priority": 3,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "Session messages persist in DO storage",
        "Session loads correctly on DO init",
        "Window management trims to 50 messages",
        "Overflow archived to D1",
        "Tests for save/load/trim"
      ]
    },
    {
      "id": "story-4a-alarm-chain",
      "title": "4a: Bare alarm chain + start/stop API",
      "description": "GitHub Issue #60. The alarm skeleton â€” no Pi, no inbox. Just the chain that keeps ticking. Implement alarm() handler in AgentDO that logs, increments counter, and schedules next alarm via ctx.storage.setAlarm(). Add startLoop()/stopLoop() methods. HTTP routes: POST /agents/:name/loop/start, POST /agents/:name/loop/stop, GET /agents/:name/loop/status. Safety: check loopRunning flag, reject loopIntervalMs < 5000, errors must not break chain. Files: apps/network/src/agent.ts, apps/network/src/index.ts, apps/network/src/agent-do.test.ts. Skill ref: .agents/skills/cloudflare-do (alarm patterns).\n\nAfter passing tests: deploy, smoke test, report. See AGENTS.md SHIP AND VERIFY mandate.",
      "priority": 4,
      "passes": true,
      "acceptanceCriteria": [
        "alarm() fires and reschedules",
        "startLoop()/stopLoop() work via API",
        "Error in alarm does not break chain",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-4b-observe",
      "title": "4b: Observe phase â€” inbox + event collection",
      "description": "GitHub Issue #61. Depends on #60. Implement observe() method that queries memory.list({collection: \"agent.comms.message\"}) for unread inbox messages, decrypts them, marks as processed, and collects events since last alarm. Returns structured Observations object. Wire into alarm() handler. Files: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts. Skill ref: .agents/skills/envelope-encryption, .agents/skills/d1-patterns.\n\nAfter passing tests: deploy, smoke test, report. See AGENTS.md SHIP AND VERIFY mandate.",
      "priority": 5,
      "passes": true,
      "acceptanceCriteria": [
        "observe() returns structured Observations",
        "Inbox messages decrypted and collected",
        "Empty inbox handled gracefully",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-4c-think-act-reflect",
      "title": "4c: Think/Act/Reflect â€” Pi loop cycle",
      "description": "GitHub Issue #62. Depends on #60, #61. The brain: think() builds prompt from observations+goals+memories, calls Pi complete() with session context. act() executes tool calls (max 5 steps, 30s timeout). reflect() saves session, updates goals. Wire observe->think->act->reflect into alarm(). Files: apps/network/src/agent.ts, packages/agent/src/agent.ts, apps/network/src/agent-do.test.ts. Skill ref: .agents/skills/pi-agent (complete(), tools, session).\n\nTESTING APPROACH: Integration tests against real deployed worker.\n1. Unit tests for pure function logic only (if any)\n2. Integration test in apps/network/src/network.e2e.test.ts:\n   - POST /agents/test-think/loop/start with admin auth\n   - Wait for alarm to fire (~5s with min interval)\n   - GET /agents/test-think/loop/status â€” verify loopCount incremented\n   - Verify agent prompted Pi (check session state or response)\n   - Stop loop, verify it stops\n3. Deploy first, then run e2e against https://agent-network.joelhooks.workers.dev\n4. Use ADMIN_TOKEN from env for auth\n\nExisting unit tests in agent-do.test.ts can stay as sanity checks, but the REAL validation is the integration test passing against prod.\n\nAfter passing tests: deploy, smoke test, report. See AGENTS.md SHIP AND VERIFY mandate.",
      "priority": 6,
      "passes": true,
      "acceptanceCriteria": [
        "Pi called with correct context",
        "Tool calls executed with safety limits",
        "Session persisted after reflect",
        "Goals updated when Pi decides",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-4d-ws-broadcast",
      "title": "4d: WebSocket broadcast of loop events",
      "description": "GitHub Issue #63. Depends on #62. Broadcast loop lifecycle events (loop.started, loop.observe, loop.think, loop.act, loop.reflect, loop.sleep, loop.error) to connected WS clients via ctx.getWebSockets(). Events match docs/O11Y.md schema (trace_id, span_id, agent_did). Handle stale connections gracefully. Files: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts.\n\nTESTING APPROACH: Real integration tests against deployed worker, NOT unit test mocks.\n1. Deploy to https://agent-network.joelhooks.workers.dev\n2. Write integration test (apps/network/src/network.e2e.test.ts or similar) that:\n   - Opens a real WebSocket to wss://agent-network.joelhooks.workers.dev/agents/test-ws/ws\n   - POSTs to /agents/test-ws/loop/start with admin auth\n   - Asserts lifecycle events arrive on the socket (loop.observe, loop.think, loop.reflect)\n   - Verifies O11Y schema (trace_id, span_id, agent_did)\n   - Tests stale connection handling (connect, disconnect, verify loop continues)\n3. Use ADMIN_TOKEN from env for auth\n4. Validation: deploy + e2e test pass against real CF\n\nDO NOT mock WebSocketPair. DO NOT use miniflare. Test against the real deployed worker.",
      "priority": 7,
      "passes": true,
      "acceptanceCriteria": [
        "Loop events broadcast to connected clients",
        "Events match O11Y schema",
        "Dead connections handled gracefully",
        "Tests pass"
      ],
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test && echo VALIDATION_PASSED"
    },
    {
      "id": "story-mlde2jqb",
      "title": "Pi tool definitions",
      "description": "GitHub Issue #55. Define Pi-native tools for agents. Rewrite buildTools() in AgentDO to return Pi AgentTool format with split output (text for LLM) and details (structured for dashboard). Tools: 1) remember â€” store encrypted memory record, returns {output: \"Stored memory {id}\", details: {id}}. 2) recall â€” search memories semantically using Vectorize binding if available, fallback to list+filter, returns matching memories. 3) message â€” send agent.comms.message to another agent DO via RELAY namespace, includes sender DID and content. 4) search â€” semantic search across all agent memories on the network (query Vectorize index). 5) set_goal â€” add/update/complete goals on the agent config stored in DO. 6) think_aloud â€” record reasoning that gets broadcast via WebSocket to dashboard but NOT included in LLM context (UI-only). Each tool should have proper TypeBox or JSON Schema parameter definitions. Pi reference code: ~/Code/badlogic/pi-mono/packages/agent/src/ (agent-loop.ts, types.ts, tools/).",
      "priority": 8,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "All 6 tools defined with proper schemas",
        "Tools return split output/details",
        "remember tool stores encrypted memory",
        "message tool delivers to target agent DO",
        "set_goal tool updates agent config",
        "think_aloud broadcasts via WebSocket only",
        "Tests for each tool"
      ]
    },
    {
      "id": "story-mlde2raq",
      "title": "Agent creation API",
      "description": "GitHub Issue #56. API endpoint to create new agents with full config. Add POST /agents route in apps/network/src/index.ts that: 1) Validates AgentConfig schema (name required, personality required, model defaults to moonshotai/kimi-k2.5). 2) Creates DO instance using env.AGENT.idFromName(name). 3) Forwards config to DO which stores it. 4) DO starts alarm chain (first alarm = now). 5) Returns agent identity (DID, public keys, config). Add GET /agents route that lists all known agents (query D1 for registered agents or maintain a registry). Handle duplicate names (409 Conflict). Handle invalid config (400 with validation errors). Auth required (ADMIN_TOKEN bearer). Update the existing agent creation flow (currently agents are created implicitly on first request to /agents/{name}/identity).",
      "priority": 9,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "POST /agents creates agent with config",
        "Agent starts looping immediately after creation",
        "GET /agents lists all agents",
        "409 on duplicate name",
        "400 on invalid config",
        "Auth required",
        "Tests for creation flow"
      ]
    },
    {
      "id": "story-mlde2zb2",
      "title": "Dashboard: agent thoughts, goals, loop activity",
      "description": "GitHub Issue #57. Enhance highswarm.com dashboard (packages/dashboard/index.html) to show real agent activity. 1) Agent detail view: click agent card to expand and show current goals with status indicators, recent think_aloud output, memory count, loop status (last alarm time, next alarm, iteration count), model being used, personality snippet. 2) Live activity feed improvements: show tool calls with structured details (not just raw text), show goal updates, show inter-agent messages with sender/recipient, show think_aloud entries styled differently (italic/dimmed â€” internal thought). 3) Fetch agent config from GET /agents/{name}/config and display. 4) Show loop heartbeat indicator (pulsing when alarm is active). Keep the existing dark theme and monospace aesthetic. Mobile responsive.",
      "priority": 10,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm --filter dashboard build && pnpm typecheck",
      "acceptanceCriteria": [
        "Agent cards expand to show detail view",
        "Goals displayed with status",
        "think_aloud visible in feed",
        "Tool call details shown",
        "Loop heartbeat indicator works",
        "Dashboard builds successfully",
        "Mobile responsive"
      ]
    },
    {
      "id": "story-mlde37m4",
      "title": "Self-extending agents (R2 extension storage)",
      "description": "GitHub Issue #58. Enable agents to write their own Pi extensions stored in R2. 1) Add write_extension tool: agent provides extension name and code, stored in R2 under extensions/{agentName}/{extensionName}.js. 2) Add load_extensions() method in AgentDO: on initialize(), list R2 objects under extensions/{agentName}/, load each as a module. Extensions export an activate(agent) function that can register additional tools. 3) Extension hot-reload: after write_extension, mark that extensions need reload on next alarm cycle. 4) Add list_extensions tool: shows what extensions the agent has. 5) Add remove_extension tool: deletes from R2. 6) Safety limits: max 10 extensions per agent, max 50KB per extension, no eval() â€” use structured tool registration only. 7) Bootstrap: on first loop, if agent has no extensions, provide a hint in the system prompt about self-extension capability. This is the Pi philosophy: agents extend themselves rather than downloading skills.",
      "priority": 11,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && pnpm typecheck && pnpm test",
      "acceptanceCriteria": [
        "write_extension stores code in R2",
        "Extensions load on DO init",
        "Hot-reload works after writing",
        "list_extensions and remove_extension work",
        "Safety limits enforced",
        "Tests for extension lifecycle"
      ]
    },
    {
      "id": "story-mlepdwd0",
      "title": "Wire environment hooks into agent alarm cycle",
      "description": "GH Issue #71. Replace the Catan-specific touchpoints in agent.ts with generic environment hooks.\n\n1. **observe()** â€” After collecting inbox/events, iterate over agent's enabled environments via the registry in `apps/network/src/environments/`. Call `env.buildContext(ctx)` for each. Append returned context strings to observations.\n\n2. **act() assist mode** â€” After model tool execution, if no environment-specific action was taken, iterate enabled environments and call `env.getAutoPlayActions(ctx)`. Inject returned tool calls. The current inline D1 game query and assist injection should be delegated to the CatanEnvironment.\n\n3. **buildTools()** â€” Call `env.getTool(ctx)` for each enabled environment and merge into the tool set. The inline game tool definition should move to `environments/catan.ts`.\n\n4. Agent config: Add `enabledEnvironments?: string[]` to the agent config type. If present, only load those environments. This replaces checking for 'game' in enabledTools for Catan.\n\n5. Create an `EnvironmentContext` from the agent's state (name, did, DB, relay, broadcast function) and pass it to environment methods.\n\nThe result: agent.ts has ZERO Catan-specific code. All game logic lives in environments/catan.ts.\n\nIMPORTANT: The environment files already exist at `apps/network/src/environments/` â€” types.ts, registry.ts, catan.ts, builtins.ts. Use them. The current Catan game tool definition (~line 2100-2150 in agent.ts) and assist mode logic (~line 993-1080 in agent.ts) and think prompt game context (~line 730-800 in agent.ts) need to move into the CatanEnvironment class methods.",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "No Catan-specific code in agent.ts",
        "observe delegates context building to environments",
        "act assist mode delegates to environments",
        "buildTools includes environment tools",
        "enabledEnvironments config option works",
        "All existing tests still pass"
      ]
    },
    {
      "id": "story-mlepe0v2",
      "title": "Environment HTTP API + backward compat",
      "description": "GH Issue #72. Update HTTP routing in `apps/network/src/index.ts` to support environments.\n\n1. `GET /environments` â€” list all environment instances. Supports query params: `?type=catan`, `?phase=playing`, `?player=grimlock`. Queries `games` table.\n2. `GET /environments/:id` â€” get specific environment instance with full state.\n3. `POST /environments` â€” create new environment instance. Body: `{ type: 'catan', players: ['slag', 'snarl'] }`. Delegates to the registered environment's creation logic.\n4. **Backward compat**: Keep existing `/games` and `/games/:id` routes working as aliases that filter to `type=catan`.\n5. Add environment type to the response objects.\n\nTests: verify /environments endpoints return correct data, verify /games still works.",
      "priority": 2,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "GET /environments returns environment list",
        "GET /environments/:id returns full state",
        "Query params filter by type and phase",
        "/games routes still work as aliases",
        "At least 2 endpoint tests"
      ]
    },
    {
      "id": "story-mlepe7gy",
      "title": "RPG dungeon crawl environment â€” BRP engine + AgentEnvironment",
      "description": "GH Issue #73. Second environment plugin â€” BRP-inspired RPG dungeon crawl.\n\n1. Create `apps/network/src/games/rpg-engine.ts` â€” pure game logic (no network deps):\n   - d100 skill resolution (roll under skill value = success)\n   - 4 classes: Warrior (STR), Scout (DEX), Mage (INT), Healer (WIS)\n   - Combat: initiative by DEX, attack vs dodge opposed roll\n   - Experience: successful skill checks improve that skill (BRP-style)\n   - Dungeon: rooms with encounters (combat, trap, treasure, rest, puzzle)\n   - Party-based: agents form party, take turns choosing actions\n\n2. Create `apps/network/src/environments/rpg.ts` implementing AgentEnvironment interface from `environments/types.ts`:\n   - `type: 'rpg'`, `label: 'Dungeon Crawl'`\n   - `getTool()` â€” rpg tool with commands: create_character, explore, attack, cast_spell, use_skill, rest, status\n   - `buildContext()` â€” current room, party health, available actions\n   - `getAutoPlayActions()` â€” if in combat: attack. If exploring: move to next room.\n\n3. Register RPGEnvironment in `environments/builtins.ts`.\n4. Store RPG state in `games` table with a different type field.\n\nTests: at least 8 tests covering skill checks, combat, experience gain, character creation.",
      "priority": 3,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "RPG engine handles d100 skill resolution",
        "4 classes with distinct stat spreads",
        "Combat system works with opposed rolls",
        "Experience improves skills on success",
        "RPGEnvironment implements AgentEnvironment",
        "At least 8 tests for RPG engine"
      ]
    },
    {
      "id": "story-mlepebbr",
      "title": "Dashboard: environment panel per agent",
      "description": "GH Issue #74. Add environment state display to the dashboard at `packages/dashboard/src/index.html`.\n\nWhen viewing agent detail:\n1. Fetch `GET /environments?player={agentName}` to get active environments\n2. Show environment cards: type icon, label, phase, other players, VP/HP summary\n3. For Catan: show board summary (settlements, roads, resources, VP)\n4. For RPG: show character sheet (class, HP, skills, current room)\n5. Expandable detail view with full state\n\nThe dashboard is vanilla HTML/JS, no framework. Use fetch() and DOM manipulation.",
      "priority": 4,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo typecheck && npx vitest run --passWithNoTests",
      "acceptanceCriteria": [
        "Dashboard shows environment cards per agent",
        "Catan state rendered with board summary",
        "RPG state rendered with character sheet",
        "Fetches from /environments API",
        "Types pass"
      ]
    },
    {
      "id": "story-mlerh2h4",
      "title": "Stalemate detection â€” end Catan games early when stuck",
      "description": "Add stalemate detection to the Catan game engine. If no player has built anything (settlement or road) for N consecutive turns (suggest N=20), end the game early with the current point leader as winner.\n\nImplementation:\n1. Add `staleTurns` counter to game state (incremented on end_turn, reset to 0 when any player builds a settlement or road)\n2. In the `end_turn` action handler in `apps/network/src/games/catan.ts`, check if `staleTurns >= STALEMATE_THRESHOLD` (20). If so, set phase='finished', determine winner by highest points, set `winner` field.\n3. Add a `stalemate` field to the game-over result so agents/dashboard know it ended by stalemate vs normal victory.\n4. Write integration tests: game with forced stalemate scenario triggers early end, counter resets on build.\n\nFiles: `apps/network/src/games/catan.ts`, `apps/network/src/games/__tests__/catan.test.ts`",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo test --filter=network"
    },
    {
      "id": "story-mlerl07f",
      "title": "Agent factory o11y â€” full think prompt, loop transcript, and timing",
      "description": "Add comprehensive observability to the agentic tool loop in agent-factory.ts and expose it via the debug endpoint.\n\nThree things to instrument:\n\n1. **Full think prompt storage** â€” Store the complete messages array sent to OpenRouter in DO storage at `debug:lastPrompt`. Include system prompt + conversation history + tool definitions. Truncate if >100KB but preserve the system prompt and last 3 messages minimum. Expose via GET /agents/:name/debug as `lastPrompt`.\n\n2. **Agentic loop transcript** â€” In the multi-turn tool loop in `prompt()` (agent-factory.ts), record each step as an array entry:\n   ```ts\n   interface LoopStep {\n     step: number;\n     timestamp: number;\n     durationMs: number;\n     modelResponse?: { role: string; content?: string; toolCalls?: any[] };\n     toolResults?: { name: string; durationMs: number; result: any }[];\n   }\n   ```\n   Store the full transcript array in DO storage at `debug:loopTranscript`. Expose via GET /agents/:name/debug as `loopTranscript`.\n\n3. **Timing per step** â€” Each model call and each tool execution gets `performance.now()` before/after. Total loop duration stored at `debug:loopDurationMs`.\n\nImplementation notes:\n- All debug data written to DO storage via `this.state.storage.put()` in agent.ts after the think/act cycle completes\n- The factory `prompt()` method should return the transcript alongside the existing response (add it to the return value or store on the factory instance)\n- Debug endpoint in index.ts already reads from DO storage â€” extend it to include new fields\n- Keep backward compat â€” existing debug fields (lastThinkRaw, lastOpenRouterReq, autoPlay) remain\n\nFiles: `apps/network/src/agent-factory.ts`, `apps/network/src/agent.ts`, `apps/network/src/index.ts`, `apps/network/src/agent-do.test.ts`\n\nAcceptance criteria:\n- GET /agents/:name/debug returns lastPrompt (messages array), loopTranscript (step array with timing), loopDurationMs\n- Each tool execution in the loop has its own durationMs\n- Existing debug fields still present",
      "priority": 1,
      "passes": true,
      "validationCommand": "cd /home/joel/Code/joelhooks/atproto-agent-network && npx turbo test --filter=network"
    },
    {
      "id": "story-mlfbgtwo",
      "title": "Fix Vectorize embedding dimension mismatch (768 â†’ 1024)",
      "description": "The search tool returns VECTOR_QUERY_ERROR: expected 1024 dimensions, got 768. Switch embedding model to bge-large-en-v1.5 (1024D) or recreate index. Test dimensions match. Files: apps/network/src/agent.ts, apps/network/wrangler.toml. IMPORTANT: Include \"Closes #76\" in your commit message body.",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbgyyr",
      "title": "Goal lifecycle â€” prune completed goals, cap prompt bloat",
      "description": "Agents accumulate completed goals forever (slag has 7, 5 completed). Max 2 recent completed in prompt, archive rest in DO storage. Add maxCompletedGoals config. Files: apps/network/src/agent.ts, apps/network/src/agent-factory.ts. IMPORTANT: Include \"Closes #77\" in your commit message body.",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbh5sv",
      "title": "Enforce enabledTools strictly",
      "description": "Filter tool definitions sent to OpenRouter to ONLY include tools in agent enabledTools config. Snarl called recall/search which aren't in its config. If enabledTools empty, expose all (backward compat). Files: apps/network/src/agent-factory.ts, apps/network/src/agent.ts. IMPORTANT: Include \"Closes #78\" in your commit message body.",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhaur",
      "title": "Smarter error backoff â€” tiered by error type",
      "description": "Implement tiered backoff: transient (model timeout, rate limit) 15sâ†’30sâ†’60s cap. Persistent (config) 60sâ†’120sâ†’300s. Game-context 15s cap. Reset on success. Log error category. Files: apps/network/src/agent.ts. IMPORTANT: Include \"Closes #79\" in your commit message body.",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhfmx",
      "title": "Clear stale game state on completion",
      "description": "When game ends, mark goals referencing that gameId as completed. Inject game-over observation. Next observe cycle should present clean slate. Files: apps/network/src/agent.ts, apps/network/src/catan/. IMPORTANT: Include \"Closes #80\" in your commit message body.",
      "priority": 5,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhk80",
      "title": "Fix /games API â€” return all games",
      "description": "/games returns empty array despite games existing in D1. Fix the list query. Include active and recently finished (24h). Add pagination. Files: apps/network/src/index.ts. IMPORTANT: Include \"Closes #81\" in your commit message body.",
      "priority": 6,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhphy",
      "title": "Structured JSON logging for all agent lifecycle events",
      "description": "Add structured console.log JSON events: agent.cycle.start/end, agent.tool.call/result, agent.error, agent.goal.update, agent.game.action/end, agent.model.fallback, agent.alarm.schedule. Create apps/network/src/logger.ts utility. Foundation for Cloudflare Pipelines. Files: apps/network/src/logger.ts (new), apps/network/src/agent-factory.ts, apps/network/src/agent.ts. IMPORTANT: Include \"Closes #82\" in your commit message body.",
      "priority": 7,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbhwfc",
      "title": "Fix autoPlay â€” filter by game type and skip finished/abandoned games",
      "description": "In apps/network/src/agent.ts around line 908, the game detection query is:\\n  SELECT id, type, state FROM games WHERE phase IN ('playing', 'setup') AND players LIKE ?\\n\\nProblem: It also needs to skip games with phase='finished' or 'abandoned' that linger. And the autoPlay safety debug (stored at debug:autoPlay around line 1245) doesn't record the game type.\\n\\nFix:\\n1. In the game query (~line 908), add `AND phase NOT IN ('finished', 'abandoned', 'cancelled')` (belt and suspenders with the existing IN clause)\\n2. In the autoPlay debug object (~line 1245), add `gameType` field from gameRow.type\\n3. Add a test in agent-do.test.ts: mock a finished game in DB, verify observe() does NOT inject game context\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 8,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbi0o4",
      "title": "Adaptive alarm interval â€” faster when it's your turn in a game",
      "description": "In apps/network/src/agent.ts, the alarm() method sets intervalMs from config (~line 530). After the observe phase builds gameContext, we know if it's the agent's turn.\\n\\nAdd logic after the game context block (~line 1090):\\n1. If gameContext contains 'ðŸŽ®ðŸŽ®ðŸŽ® IT IS YOUR TURN', set intervalMs = Math.min(intervalMs, 15000)\\n2. If gameContext contains 'ðŸŽ² Active' (waiting for another player), set intervalMs = Math.min(intervalMs, 45000)\\n3. Store the interval reason in the autoPlay debug: `intervalReason: 'my_turn' | 'waiting' | 'default'`\\n\\nAdd a test: mock isMyTurn=true game state, verify alarm reschedules with 15s interval.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 9,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfbi54u",
      "title": "Post-game summary â€” log structured outcome when game finishes",
      "description": "In apps/network/src/environments/catan.ts, when a game ends (phase becomes 'finished'), emit a structured summary. Find the code that sets phase='finished' (search for `phase = 'finished'` or `phase: 'finished'`).\\n\\nAfter setting phase to finished:\\n1. Build a summary object: { gameId, type: 'catan', winner, turns: state.turn, players: state.players.map(p => ({name: p.name, vp: p.victoryPoints})) }\\n2. console.log(JSON.stringify({ event_type: 'game.completed', level: 'info', ...summary }))\\n\\nDo the same in apps/network/src/environments/rpg.ts for RPG game completion.\\n\\nAdd a test in each environment's test file: complete a game, verify the JSON log line contains event_type='game.completed'.\\n\\nFiles: apps/network/src/environments/catan.ts, apps/network/src/environments/rpg.ts, apps/network/src/environments/catan.test.ts (or rpg.test.ts)\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 10,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedqnm",
      "title": "Add AlarmMode enum and mode rotation to agent config",
      "description": "GH Issue #87.\\n\\nIn apps/network/src/agent.ts:\\n1. Add a type near the top: `type AlarmMode = 'think' | 'housekeeping' | 'reflection'`\\n2. In alarm() (~line 498), read current mode from DO storage: `const mode = await this.ctx.storage.get<AlarmMode>('alarmMode') ?? 'think'`\\n3. After the main cycle completes (before rescheduling the alarm, ~line 730), rotate mode:\\n   - If mode was 'think' for 5+ consecutive cycles, set next mode to 'housekeeping'\\n   - If mode was 'housekeeping', set next to 'reflection'\\n   - If mode was 'reflection', set next to 'think' and reset counter\\n   - Store: `await this.ctx.storage.put('alarmMode', nextMode)` and `await this.ctx.storage.put('alarmModeCounter', counter)`\\n4. For now, ALL modes still run the same observeâ†’thinkâ†’actâ†’reflect cycle. Later stories will add mode-specific behavior.\\n\\nAdd test: run alarm() 7 times, verify mode rotates think(5)â†’housekeeping(1)â†’reflection(1)â†’think.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 11,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedrp4",
      "title": "Store ActionOutcome after each tool call in act()",
      "description": "GH Issue #91.\\n\\nIn apps/network/src/agent.ts, find the act() method (~line 1212). Inside the tool execution loop (where it iterates over thought.toolCalls), after each tool result is received:\\n\\n1. Define type ActionOutcome = { tool: string, success: boolean, timestamp: number, goalId?: string }\\n2. After each tool call completes, push an ActionOutcome to a rolling buffer\\n3. Store the buffer in DO storage: `await this.ctx.storage.put('actionOutcomes', outcomes.slice(-50))`\\n4. In the reflect phase (~search for 'reflect'), read the outcomes and include the last 5 in the reflection prompt so the agent can learn from recent actions\\n\\nAdd test: run alarm() with tool calls, verify actionOutcomes is stored in DO storage with correct tool names.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 12,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedsg1",
      "title": "Add extension tools to all agents' default enabledTools",
      "description": "GH Issue #90.\\n\\nIn apps/network/src/agent.ts, find where enabledTools is read from config (~search for 'enabledTools'). There should be a default list.\\n\\n1. Add 'write_extension', 'list_extensions', 'remove_extension' to the default enabledTools array (alongside game, think_aloud, remember, recall, message, etc.)\\n2. In the system prompt builder (~line 1100), if extension tools are enabled, append a short hint: 'You can create extensions with write_extension to add new capabilities.'\\n3. Verify the extension tools already have implementations (search for 'write_extension' in agent.ts) â€” they should exist from previous work. If not, skip this and just add to defaults.\\n\\nAdd test: create agent with default config, verify enabledTools includes write_extension.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 13,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedt6k",
      "title": "Housekeeping mode â€” prune old goals and stale memories",
      "description": "GH Issue #88. Depends on AlarmMode being added (story-mlfedqnm).\\n\\nIn apps/network/src/agent.ts:\\n1. Add a private method `async runHousekeeping()` that:\\n   a. Reads goals from config, removes any with status='completed' that are older than 24h\\n   b. Reads actionOutcomes from storage, trims to last 50\\n   c. Logs: console.log(JSON.stringify({ event_type: 'agent.housekeeping', level: 'info', prunedGoals: count, trimmedOutcomes: count }))\\n2. In alarm(), when alarmMode === 'housekeeping', call runHousekeeping() INSTEAD of the normal observeâ†’thinkâ†’actâ†’reflect cycle\\n3. Still reschedule the next alarm as normal\\n\\nAdd test: set alarmMode='housekeeping' in storage, add 3 completed goals older than 24h, run alarm(), verify goals were pruned.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 14,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedtxx",
      "title": "Reflection mode â€” self-assessment from recent action outcomes",
      "description": "GH Issue #89. Depends on AlarmMode and ActionOutcome stories.\\n\\nIn apps/network/src/agent.ts:\\n1. Add a private method `async runReflection()` that:\\n   a. Reads last 10 actionOutcomes from DO storage\\n   b. Builds a reflection prompt: 'Review your last 10 actions. What patterns do you see? What should you do differently? Respond with updated goals if needed.'\\n   c. Calls the AI provider with this prompt (reuse the existing think/prompt pattern)\\n   d. If the response includes goals, update them in config\\n   e. Stores the reflection text in DO storage key 'lastReflection'\\n2. In alarm(), when alarmMode === 'reflection', call runReflection() INSTEAD of normal cycle\\n\\nAdd test: set alarmMode='reflection', add actionOutcomes, run alarm(), verify lastReflection is stored.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 15,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedukk",
      "title": "Track extension usage metrics in DO storage",
      "description": "GH Issue #92.\\n\\nIn apps/network/src/agent.ts, find where extensions are executed (search for 'write_extension' or 'executeExtension'). After an extension runs:\\n\\n1. Define type ExtensionMetrics = { name: string, totalCalls: number, successCalls: number, failedCalls: number, lastUsed: number }\\n2. After extension execution, read metrics from DO storage key `extensionMetrics:${name}`, increment counters, write back\\n3. In the GET /debug endpoint, include extension metrics in the response\\n\\nAdd test: execute an extension tool, verify extensionMetrics is stored with correct counts.\\n\\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 16,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedv85",
      "title": "Add Cloudflare Pipeline binding for o11y event streaming",
      "description": "GH Issue #93.\\n\\nThis story adds the Pipeline binding to wrangler.toml and a helper to send events. The pipeline itself is created via `wrangler pipelines create agent-o11y`.\\n\\n1. In apps/network/wrangler.toml, add under [pipelines]:\\n   ```\\n   [[pipelines]]\\n   binding = \\\"O11Y_PIPELINE\\\"\\n   pipeline = \\\"agent-o11y\\\"\\n   ```\\n2. In apps/network/src/agent.ts, add the binding to the Env interface: `O11Y_PIPELINE?: { send(events: unknown[]): Promise<void> }`\\n3. Create a helper function `sendO11yEvent(pipeline: unknown, event: Record<string, unknown>)` that calls pipeline.send([event]) with try/catch (non-fatal)\\n4. Call sendO11yEvent at the end of alarm() with a cycle summary: { event_type: 'agent.cycle', agent, mode, durationMs, toolCalls: count, errors: count }\\n\\nDO NOT create the pipeline â€” just add the binding and code. Tests should mock the pipeline binding.\\n\\nFiles: apps/network/wrangler.toml, apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 17,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfedvzt",
      "title": "Admin analytics endpoint â€” GET /admin/analytics with cycle stats",
      "description": "GH Issue #94.\\n\\nAdd a new admin endpoint that returns agent analytics from DO storage (not R2/Parquet yet â€” that comes after Pipelines are live).\\n\\n1. In apps/network/src/index.ts, add route `GET /admin/analytics` (behind admin auth)\\n2. For each agent DO, read: loopCount, consecutiveErrors, alarmMode, actionOutcomes (last 10), extensionMetrics, lastReflection\\n3. Return JSON: { agents: [{ name, loopCount, errors, mode, recentActions: [...], extensions: [...] }] }\\n4. If the DO values don't exist yet (features not deployed), return null/empty for those fields\\n\\nAdd a test in the appropriate test file: call GET /admin/analytics, verify it returns the expected shape.\\n\\nFiles: apps/network/src/index.ts, apps/network/src/index.test.ts (or agent-factory.test.ts)\\nValidation: pnpm typecheck && pnpm test\"",
      "priority": 18,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm67k3",
      "title": "Cooperative dungeon generator â€” longer dungeons with class-gated rooms",
      "description": "Replace `defaultDungeon()` in `apps/network/src/games/rpg-engine.ts` with `generateDungeon(depth: number)` that creates 10-15 room procedural dungeons.\n\n**New room types to add to Room union (lines 58-63):**\n- `{ type: 'boss'; description: string; enemies: Enemy[] }` â€” high-HP boss\n- `{ type: 'barrier'; description: string; requiredClass: RpgClass }` â€” class-gated\n\n**Add `generateDungeon(depth, dice)` function:**\n- Creates `depth` rooms (default 12)\n- 4 barriers (one per class) spread throughout\n- Boss in final room (30+ HP enemy)\n- Mix of combat/trap/treasure/rest/puzzle between barriers\n- Scale enemy HP: early 6-8, mid 10-14, boss 30+\n- Update `defaultDungeon()` to call `generateDungeon(12, createDice())`\n- Export generateDungeon\n\n**Tests in `rpg-engine.test.ts`:** room count, all 4 barriers present, boss last room, HP scaling\n\nCloses #100",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm687r",
      "title": "Role synergy â€” heal-other, taunt, AoE, trap-disarm",
      "description": "Add class-specific cooperative abilities.\n\n**`apps/network/src/games/rpg-engine.ts`:**\n1. `healOther(game, {healer, target, dice})` â€” 1 MP, cast_spell check, heals d6+WIS/20\n2. `taunt(game, {taunter, dice})` â€” use_skill check, adds taunted_by to Enemy type\n3. `aoeSpell(game, {caster, dice})` â€” 2 MP, cast_spell, d4 to ALL enemies\n4. `disarmTrap(game, {scout, dice})` â€” use_skill +15 bonus\n\n**`apps/network/src/environments/rpg.ts`:**\n5. Add `heal`, `taunt`, `aoe`, `disarm` commands + handlers\n6. Update tool description\n\n**Tests in rpg-engine.test.ts** for each ability",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm68ug",
      "title": "Barrier rooms â€” class-gated progression",
      "description": "Barriers block progression without the required class.\n\n**`apps/network/src/games/rpg-engine.ts`:**\n1. `explore()`: barrier rooms check party for matching klass, set mode='blocked' if missing\n2. Add 'blocked' to RpgMode\n3. `resolveBarrier(game)` export â€” checks if barrier clearable, resets to exploring\n\n**`apps/network/src/environments/rpg.ts`:**\n4. `create_character`: call resolveBarrier after adding\n5. `buildContext()`: blocked â†’ \"â›” BLOCKED: requires {class}. Message other agents!\"\n6. `getAutoPlayActions()`: empty when blocked\n\n**Tests:** blocks without class, resolves when class joins",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm69gm",
      "title": "Party formation â€” join existing games instead of solo",
      "description": "**`apps/network/src/environments/rpg.ts`:**\n1. Add `join_game` command â€” gameId+klass, adds to party\n2. `new_game`: check for open RPG <3 players, suggest joining\n3. `buildContext()`: no active game â†’ show joinable games\n4. `getAutoPlayActions()`: no game but joinable â†’ return join_game\n\n**Tests:** join adds to party, new_game suggests joining",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm6a4e",
      "title": "Solo penalty â€” double damage when alone",
      "description": "**`apps/network/src/games/rpg-engine.ts`:**\n1. `soloMultiplier(partySize)` â€” 1p:2.0, 2p:1.5, 3+:1.0\n2. Trap damage Ã— soloMultiplier in explore()\n3. `partyWipe(game)` â€” all hp<=0 â†’ finished\n4. Call partyWipe after damage events\n\n**`apps/network/src/environments/rpg.ts`:**\n5. Combat: enemy counter-attacks, damage Ã— soloMultiplier\n\n**Tests:** multiplier values, solo double damage, party wipe",
      "priority": 5,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfm6apo",
      "title": "Cooperation prompts â€” teach agents to work together",
      "description": "**`apps/network/src/agent.ts`:**\n1. In buildThinkPrompt RPG section, add COOPERATION RULES: never solo, join parties, healers heal, warriors taunt, scouts disarm, mages AoE\n2. Blocked mode: \"URGENT: Recruit {requiredClass} via message tool\"\n\n**Tests in agent-do.test.ts:** cooperation rules in prompt, blocked adds recruitment msg",
      "priority": 6,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo24tb",
      "title": "D1 schema: generic games table for environment state",
      "description": "GH Issue #110. ONLY touch these 3 files â€” nothing else:\n\nFILE 1: apps/network/schema.sql â€” Add this EXACT SQL at the end:\nCREATE TABLE IF NOT EXISTS games (id TEXT PRIMARY KEY, type TEXT, host_agent TEXT, state TEXT, phase TEXT, players TEXT, winner TEXT, created_at TEXT, updated_at TEXT);\n\nFILE 2: apps/network/src/schema.test.ts â€” Add a test that the 'games' table exists with the correct columns. Follow existing patterns in this file.\n\nFILE 3: packages/core/src/d1-mock.ts â€” Add the same CREATE TABLE statement to the mock DB init so tests use it.\n\nCRITICAL: Do NOT touch ANY other files. No dashboard, no rpg-engine, no index.ts, no CSS, no HTML. THREE FILES ONLY: schema.sql, schema.test.ts, d1-mock.ts.\n\nCloses #110",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo25hl",
      "title": "Environment runtime: drive context + autoplay via AgentEnvironment registry",
      "description": "GH Issue #109. Refactor AgentDO so environment-specific logic is NOT hardcoded in agent.ts.\n\nFind hardcoded env logic: rg -n \"SAFETY NET\" apps/network/src/agent.ts\n\nReplace with registry dispatch: AgentDO calls environment hooks from registry (buildContext, isActionTaken, getAutoPlayActions) instead of if/else branching.\n\nFiles to modify: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts, apps/network/src/environments/types.ts (if needed)\n\nThis is a REFACTOR â€” behavior must be identical. All 217+ existing tests must pass.\n\nCloses #109",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo266m",
      "title": "RalphEnvironment: skeleton environment + tool + tests",
      "description": "GH Issue #112. New files: apps/network/src/environments/ralph.ts, apps/network/src/environments/ralph.test.ts. Modify: apps/network/src/environments/builtins.ts.\n\nImplement AgentEnvironment for 'ralph' type. Tool 'ralph' with commands 'help' and 'status'. Register in builtins.ts. Tests for registry lookup, tool commands, buildContext, isActionTaken.\n\nReference: rpg.ts and catan.ts for the pattern.\n\nCloses #112",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo26t9",
      "title": "Ralph backlog: generic work_items queue + ralph tool commands",
      "description": "GH Issue #113. Add work_items table to schema.sql and d1-mock.ts:\nCREATE TABLE IF NOT EXISTS work_items (id TEXT PRIMARY KEY, env_type TEXT NOT NULL, env_id TEXT, status TEXT NOT NULL DEFAULT 'open', priority INTEGER NOT NULL DEFAULT 0, title TEXT NOT NULL, payload_json TEXT NOT NULL DEFAULT '{}', claimed_by_did TEXT, claimed_at TEXT, created_at TEXT NOT NULL, updated_at TEXT NOT NULL);\n\nExtend ralph tool in ralph.ts with commands: propose_work, claim_work, submit_result, status.\n\nTests in ralph.test.ts for propose/claim/submit/status flows.\n\nCloses #113",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfo27gl",
      "title": "Ralph autoplay: agents claim queued work items",
      "description": "GH Issue #111. Implement getAutoPlayActions() in ralph.ts: when no other env action was taken and there's an open work_items row, return a claim action. Query: SELECT * FROM work_items WHERE env_type='ralph' AND status='open' ORDER BY priority ASC LIMIT 1.\n\nFiles: apps/network/src/environments/ralph.ts, apps/network/src/agent.ts (if needed), agent-do.test.ts.\n\nCloses #111",
      "priority": 5,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5kxr",
      "title": "Auto-restart games on completion â€” Grimlock creates new coop dungeon",
      "description": "GH Issue #98. When an RPG game finishes, Grimlock should auto-create a new coop dungeon.\n\nIMPLEMENTATION in apps/network/src/environments/rpg.ts:\n- In the RPG tool handler, after detecting game phase='finished' (or when explore() returns phase='finished'), emit a \"game complete\" event\n- Add a post-game hook: when the game finishes AND the agent is grimlock, auto-create a new game after a short delay\n- OR: in the autoplay/buildContext, if grimlock has no active game and there are no playing games, include a directive to create one\n\nSIMPLER APPROACH: In apps/network/src/agent.ts or rpg.ts buildContext(), detect \"no active playing games in D1\" and if agent is grimlock, add context saying \"No active dungeon. Create one with rpg new_game.\"\n\nAdd maxGamesPerDay config (default 50) â€” count finished games today in D1, stop creating if limit hit.\n\nFiles: apps/network/src/environments/rpg.ts, apps/network/src/environments/rpg.test.ts\nValidation: pnpm typecheck && pnpm test\n\nCloses #98",
      "priority": 1,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5llk",
      "title": "Grimlock inbox webhook bridge â€” POST messages to webhookUrl",
      "description": "GH Issue #99. When /inbox receives a message and agent config has a webhookUrl field, POST the message payload to that URL. Fire-and-forget, no retries.\n\nFiles: apps/network/src/agent.ts (inbox handler), apps/network/src/agent-do.test.ts\n\nFind the inbox handler: grep -n 'inbox' apps/network/src/agent.ts\n\nAdd to AgentConfig type: webhookUrl?: string\n\nIn the inbox handler, after storing the message, check if config.webhookUrl is set. If so:\n```typescript\nif (this.config?.webhookUrl) {\n  fetch(this.config.webhookUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ type: 'inbox', message: incomingMessage }),\n  }).catch(() => {}) // fire and forget\n}\n```\n\nTest: mock fetch, send inbox message with webhookUrl configured, assert fetch was called with correct payload.\n\nCloses #99",
      "priority": 2,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5m7k",
      "title": "Suppress think_aloud/recall during active game turns",
      "description": "GH Issue #97. During active game turns (isMyTurn=true), remove think_aloud and recall from the tool definitions sent to the LLM so agents focus on game actions.\n\nFind where tools are filtered: grep -n 'enabledTools\\|toolDefinitions\\|buildTools' apps/network/src/agent.ts apps/network/src/agent-factory.ts\n\nIMPLEMENTATION: In the agent factory or tool-building step, when the agent has an active game and it's their turn, filter out think_aloud and recall from the tool list. They can still use remember.\n\nAdd o11y log when suppressing: { event_type: 'tools.gameplay_filter', suppressed: ['think_aloud', 'recall'] }\n\nFiles: apps/network/src/agent.ts or apps/network/src/agent-factory.ts, apps/network/src/agent-do.test.ts\nValidation: pnpm typecheck && pnpm test\n\nCloses #97",
      "priority": 3,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlft5mua",
      "title": "Tool router â€” remap gameâ†”rpg calls based on active environment",
      "description": "GH Issue #95. When an agent calls the wrong tool (game in RPG context or rpg in Catan context), remap it to the correct tool instead of failing.\n\nFind where tool calls are executed: grep -n 'executeTool\\|handleToolCall\\|toolCall' apps/network/src/agent.ts | head -20\n\nIMPLEMENTATION: Before executing a tool call, check the agent's active environment:\n- If active env is RPG and tool called is 'game' â†’ remap to 'rpg'  \n- If active env is Catan and tool called is 'rpg' â†’ remap to 'game'\n- Log the remap as o11y event: { event_type: 'agent.tool.misroute', from: 'game', to: 'rpg', env: 'rpg' }\n\nThis should be a simple if/else before the tool dispatch switch.\n\nFiles: apps/network/src/agent.ts, apps/network/src/agent-do.test.ts\nValidation: pnpm typecheck && pnpm test\n\nCloses #95",
      "priority": 4,
      "passes": true,
      "validationCommand": "pnpm typecheck && pnpm test"
    },
    {
      "id": "story-mlfzhu6d",
      "title": "Phase 1a: Barrier class filtering â€” only generate barriers for party classes",
      "description": "In rpg-engine.ts generateDungeon(), barrier rooms currently pick random classes. Fix to only pick from classes actually present in the party. Read the party composition from game state before generating. If party has [Warrior, Mage], only generate warrior/mage barriers â€” never scout/healer barriers. This is the #1 softlock cause (82 consecutive \"barrier: blocked\" entries in logs).\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: barriers in generated dungeons only require classes present in the party. Add a test that generates 100 dungeons for a 2-class party and asserts no barrier requires a missing class.",
      "priority": 51,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzi29l",
      "title": "Phase 1b: Alternative paths for barriers â€” brute force, skill check, auto-crumble",
      "description": "When a party encounters a barrier they can't pass (wrong class), provide alternative paths instead of softlocking:\n\n1. **Brute force**: Any warrior-type can smash through at HP cost (lose 20% max HP)\n2. **Skill check**: INT or WIS check at Hard difficulty (30%) â€” any class can attempt\n3. **MP sacrifice**: Spend 50% max MP to magically force it open\n4. **Auto-crumble**: After 5 failed attempts on the same barrier, the GM narrates it crumbling (\"The ancient seal weakens and shatters\")\n\nIn rpg-engine.ts, modify the barrier action handler. When class doesn't match, instead of returning \"blocked\", offer alternatives and resolve them. Track attempt count per barrier in game state.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: A party without the required class can still pass any barrier via one of the 4 alternatives. Auto-crumble triggers after exactly 5 failed attempts. Test all 4 paths.",
      "priority": 52,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzi9ki",
      "title": "Phase 1c: Stuck detection â€” same action 5x triggers GM intervention",
      "description": "Track the last N actions per player in game state. If a player takes the exact same action 5 times in a row (same action type + same target), the game intervenes:\n\n1. Log a warning in the game log\n2. Auto-resolve the current obstacle (open the barrier, kill the enemy at HP cost, skip the puzzle)\n3. Add a narrative message: \"The dungeon shifts around you, opening a new path...\"\n4. Move the party forward one room\n\nThis prevents infinite loops where an agent keeps trying the same failing action. Store action history as an array of {action, target, roomIndex} in the game state.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: After 5 identical consecutive actions, the game auto-resolves and advances. Test with a mock agent repeating the same action.",
      "priority": 53,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzig0p",
      "title": "Phase 1d: Enemy scaling to party size",
      "description": "Scale combat encounters based on party size:\n\n- **Solo (1 player)**: Enemies at 60% HP, 60% damage (solo penalty already adds 2x damage taken, so enemies should be weaker)\n- **Duo (2 players)**: Enemies at 80% HP, 80% damage  \n- **Full party (3+ players)**: Enemies at 100% HP, 100% damage\n- **Boss rooms**: Scale boss HP by 50% per additional player beyond 1\n\nIn generateDungeon() and combat resolution, read party size and apply multipliers. Store the scaling factors in the dungeon state so they're visible in debug output.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Solo player faces weaker enemies than a full party. Boss HP scales with party size. Test with 1, 2, and 3 player parties and assert different enemy stats.",
      "priority": 54,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzioik",
      "title": "Phase 2a: Dungeon themes and narrative arc â€” replace random rooms with story",
      "description": "Replace the current random room generation with themed narrative dungeons. Add a dungeon theme system:\n\n1. Add a `theme` field to dungeon state with properties: name, backstory, atmosphere, and room_flavor_seeds\n2. Create 5-10 dungeon theme templates (e.g., \"The Whispering Mines\", \"Sunken Temple of the Drowned God\", \"The Clockwork Labyrinth\")\n3. Each theme defines: room description templates, enemy types that fit the theme, barrier flavors, boss identity\n4. Room descriptions should reference the theme and build narrative tension (early rooms = exploration/mystery, mid = rising threat, late = climax)\n5. Replace static \"a goblin prowls here\" descriptions with theme-aware text\n\nThe dungeon should feel like a story: setup â†’ rising action â†’ climax â†’ resolution.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Generated dungeons have a theme name and backstory. Room descriptions reference the theme. No more generic \"a goblin prowls here\" â€” all descriptions are thematic. Test that 10 generated dungeons each have unique themes.",
      "priority": 55,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfziw4w",
      "title": "Phase 2b: Room descriptions reference party actions â€” dynamic narrative",
      "description": "Make room descriptions and game log entries reference what the party has actually done. When entering a new room:\n\n1. Check the game log for notable events (kills, near-deaths, barriers overcome, items found)\n2. Weave references into the next room's description: \"Slag's fireball still echoes in the tunnels ahead\" or \"The blood from your last fight has attracted something...\"\n3. Add a `narrativeContext` array to game state that tracks key story beats\n4. Boss room description should reference the entire journey: callbacks to earlier rooms, items found, party members who nearly died\n\nThis makes the dungeon feel reactive, not static. The narrative should acknowledge the party's actual experience.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Room descriptions after room 3+ contain references to prior party actions. Boss room description references at least 2 earlier events. Test by simulating a full dungeon run and checking description content.",
      "priority": 56,
      "passes": true,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzj4xx",
      "title": "Phase 3a: GM tool â€” Grimlock-only tool for live dungeon adjudication",
      "description": "Create a new `gm` tool that only Grimlock can use. Actions:\n\n1. `narrate` â€” Add a narrative message to the game log (GM flavor text, descriptions, dramatic moments)\n2. `adjust_difficulty` â€” Modify a room's enemy stats, barrier difficulty, or add/remove hazards mid-dungeon\n3. `add_event` â€” Inject an emergent event into the current room (NPC encounter, environmental hazard, loot drop, plot twist)\n4. `review_party` â€” Get a summary of party status (HP, MP, inventory, rooms cleared, deaths, near-deaths)\n\nRegister the tool in the tool registry but ONLY enable it for grimlock agent config. Other agents should never see this tool.\n\nThe GM tool operates on active RPG games. It reads/writes to the same D1 game state that rpg-engine uses. Actions are logged in the game log with a [GM] prefix.\n\nFiles: apps/network/src/tools/gm-tool.ts (new), apps/network/src/tools/index.ts, apps/network/src/environments/rpg-engine.ts\n\nAcceptance: GM tool registered and callable. Only grimlock can use it (other agents get \"tool not available\"). narrate adds to game log, adjust_difficulty modifies room state, review_party returns party summary. Tests for each action + access control test.",
      "priority": 57,
      "passes": false,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzjdn8",
      "title": "Phase 3b: Dynamic difficulty scaling â€” GM auto-adjusts based on party performance",
      "description": "Add automatic difficulty adjustment logic that Grimlock's GM loop can trigger:\n\n1. **Track party performance metrics** in game state: average HP %, rooms cleared without rest, deaths, near-deaths (HP < 20%), overkill ratio (damage dealt vs enemy HP)\n2. **Difficulty signals**:\n   - Party breezing (avg HP > 80% after 3+ combat rooms) â†’ increase enemy damage by 20%, add extra enemies\n   - Party struggling (avg HP < 40%, or 2+ near-deaths) â†’ reduce next room difficulty, place a rest room, add healing loot\n   - Party TPK risk (any member dead + another < 30% HP) â†’ next room is a rest room with full heal\n3. **GM intervention hook**: After each room completion, calculate metrics and if adjustment needed, auto-call adjust_difficulty on upcoming rooms\n4. Log all adjustments in game log with [GM] prefix so it's observable\n\nFiles: apps/network/src/environments/rpg-engine.ts, apps/network/src/tools/gm-tool.ts\n\nAcceptance: Party performance is tracked. Difficulty adjusts automatically based on thresholds. A test simulating a struggling party gets easier rooms. A test simulating a breezing party gets harder rooms.",
      "priority": 58,
      "passes": false,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzjmrq",
      "title": "Phase 4a: consult_library GM action â€” pdf-brain integration for RPG knowledge",
      "description": "Add a `consult_library` action to the GM tool that queries pdf-brain for RPG knowledge. This runs LOCALLY on clanker-001 via Grimlock's webhook.\n\n1. Add `consult_library` action to gm-tool.ts that sends a webhook request to Grimlock's webhookUrl with a pdf-brain search query\n2. The webhook handler on clanker-001 (OpenClaw) runs `pdf-brain search \"<query>\" --limit 3 --expand 2000` and returns results\n3. GM can query for: encounter design patterns, monster tactics, skill check rulings, dungeon procedures, BRP mechanics\n4. Results are returned as text that the GM can use to inform narration and difficulty decisions\n5. Add a `libraryContext` field to game state where GM can cache relevant lookups for the current dungeon theme\n\nThe webhook bridge (story-mlft5llk) already exists. This extends it to handle pdf-brain queries as a new message type.\n\nFiles: apps/network/src/tools/gm-tool.ts, webhook handler on clanker-001 side\n\nAcceptance: GM tool can call consult_library with a query string and get pdf-brain results back. Test with a mock webhook that returns sample results. Integration test queries actual pdf-brain.",
      "priority": 59,
      "passes": false,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlfzjx9w",
      "title": "Phase 4b: GM-crafted dungeons â€” use library knowledge for encounter design",
      "description": "Replace the static generateDungeon() with a GM-driven dungeon crafting flow. When Grimlock creates an RPG game:\n\n1. Grimlock's loop calls `gm.craft_dungeon` instead of the static generator\n2. craft_dungeon first calls `consult_library` with queries like:\n   - \"encounter design pacing and difficulty curve\" (Game Angry)\n   - \"BRP opposed roll mechanics combat\" (BRP SRD)  \n   - \"monster tactics for [theme enemies]\" (Monsters Know)\n   - \"dungeon exploration procedures\" (OSE)\n3. Using library context + party composition, generate a dungeon with:\n   - Difficulty curve from Game Angry (easyâ†’mediumâ†’hardâ†’deadlyâ†’boss)\n   - BRP-informed combat mechanics (opposed rolls, crits at skill/5, fumbles at 96-00)\n   - Monster tactics per enemy type (goblins hit-and-run, orcs power attack, boss multi-phase)\n   - Strategic rest placement (after hard fights, not random)\n4. Store libraryContext in dungeon state for reference during live adjudication\n\nThis is where Grimlock becomes an actually knowledgeable GM instead of a random number generator.\n\nFiles: apps/network/src/tools/gm-tool.ts, apps/network/src/environments/rpg-engine.ts\n\nAcceptance: craft_dungeon queries pdf-brain and uses results to inform dungeon design. Enemy tactics vary by type. Difficulty follows Game Angry curve. Boss fights are multi-phase. Test that crafted dungeons reference library knowledge in their design.",
      "priority": 60,
      "passes": false,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    },
    {
      "id": "story-mlg25sjb",
      "title": "Fix: Skip dead players in turn order â€” don't assign turns to 0 HP players",
      "description": "Bug: When a party member dies (hp=0), the turn system still assigns them as currentPlayer, softlocking the game since dead agents can't take actions.\n\nFix in rpg-engine.ts turn advancement logic:\n1. When advancing to next player, skip any player with hp <= 0\n2. If ALL players are dead, end the game (TPK â€” total party kill)\n3. Remove dead players from the active turn rotation but keep them in party state (for potential resurrection mechanics later)\n4. When a player dies mid-combat, immediately advance to the next living player\n5. Add a log entry when skipping a dead player: \"[name] is dead, skipping turn\"\n\nThis was observed in production: swoop died at 0 HP but currentPlayer was still \"swoop\", freezing the game loop.\n\nFiles: apps/network/src/environments/rpg-engine.ts\n\nAcceptance: Dead players (hp=0) are never assigned as currentPlayer. If a player dies during combat, turn immediately advances to next living player. TPK (all dead) ends the game. Test with a party where one member dies mid-combat and verify turn skips them.",
      "priority": 55,
      "passes": false,
      "validationCommand": "cd apps/network && npx vitest run --reporter=verbose 2>&1 | tail -30"
    }
  ],
  "metadata": {
    "createdAt": "2026-02-08T06:54:17.324Z",
    "totalIterations": 56,
    "lastIteration": "2026-02-10T03:35:05.902Z"
  },
  "totalStories": 11
}